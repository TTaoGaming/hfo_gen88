{"files":{"hot_obsidian_sandbox/bronze/P0_LIDLESS_LEGION/contracts/index.ts":{"language":"typescript","mutants":[{"id":"69","mutatorName":"BlockStatement","replacement":"{}","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":4,"line":155},"start":{"column":35,"line":153}}},{"id":"70","mutatorName":"MethodExpression","replacement":"results","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":64,"line":154},"start":{"column":15,"line":154}}},{"id":"71","mutatorName":"ArrowFunction","replacement":"() => undefined","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":63,"line":154},"start":{"column":30,"line":154}}},{"id":"72","mutatorName":"ConditionalExpression","replacement":"true","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":63,"line":154},"start":{"column":35,"line":154}}},{"id":"73","mutatorName":"ConditionalExpression","replacement":"false","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":63,"line":154},"start":{"column":35,"line":154}}},{"id":"74","mutatorName":"EqualityOperator","replacement":"o.timestamp > filter.since!","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":63,"line":154},"start":{"column":35,"line":154}}},{"id":"75","mutatorName":"EqualityOperator","replacement":"o.timestamp < filter.since!","status":"NoCoverage","static":false,"coveredBy":[],"location":{"end":{"column":63,"line":154},"start":{"column":35,"line":154}}},{"id":"23","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected undefined to be true // Object.is equality","status":"Killed","static":false,"testsCompleted":8,"killedBy":["262","263","264","265","266","267","268","269"],"coveredBy":["262","263","264","265","266","267","268","269"],"location":{"end":{"column":2,"line":96},"start":{"column":56,"line":94}}},{"id":"22","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected undefined to be true // Object.is equality","status":"Killed","static":false,"testsCompleted":10,"killedBy":["260","261","262","263","264","265","266","267","268","269"],"coveredBy":["260","261","262","263","264","265","266","267","268","269"],"location":{"end":{"column":2,"line":89},"start":{"column":54,"line":87}}},{"id":"34","mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Survived","static":false,"testsCompleted":4,"coveredBy":["255","256","258","259"],"location":{"end":{"column":32,"line":124},"start":{"column":30,"line":124}}},{"id":"35","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Target cannot be null or undefined.","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":2,"line":159},"start":{"column":107,"line":132}}},{"id":"36","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Cannot read properties of undefined (reading 'includes')","status":"Killed","static":false,"testsCompleted":4,"killedBy":["271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":50,"line":136},"start":{"column":7,"line":136}}},{"id":"37","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":50,"line":136},"start":{"column":7,"line":136}}},{"id":"38","mutatorName":"LogicalOperator","replacement":"filter.sources || filter.sources.length > 0","statusReason":"Cannot read properties of undefined (reading 'length')","status":"Killed","static":false,"testsCompleted":4,"killedBy":["271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":50,"line":136},"start":{"column":7,"line":136}}},{"id":"39","mutatorName":"ConditionalExpression","replacement":"true","status":"Survived","static":false,"testsCompleted":1,"coveredBy":["270"],"location":{"end":{"column":50,"line":136},"start":{"column":25,"line":136}}},{"id":"40","mutatorName":"EqualityOperator","replacement":"filter.sources.length >= 0","status":"Survived","static":false,"testsCompleted":1,"coveredBy":["270"],"location":{"end":{"column":50,"line":136},"start":{"column":25,"line":136}}},{"id":"41","mutatorName":"EqualityOperator","replacement":"filter.sources.length <= 0","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["270"],"coveredBy":["270"],"location":{"end":{"column":50,"line":136},"start":{"column":25,"line":136}}},{"id":"42","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["270"],"coveredBy":["270"],"location":{"end":{"column":4,"line":138},"start":{"column":52,"line":136}}},{"id":"43","mutatorName":"MethodExpression","replacement":"results","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["270"],"coveredBy":["270"],"location":{"end":{"column":70,"line":137},"start":{"column":15,"line":137}}},{"id":"44","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["270"],"coveredBy":["270"],"location":{"end":{"column":69,"line":137},"start":{"column":30,"line":137}}},{"id":"45","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":41,"line":141},"start":{"column":7,"line":141}}},{"id":"46","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":4,"killedBy":["271"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":41,"line":141},"start":{"column":7,"line":141}}},{"id":"47","mutatorName":"EqualityOperator","replacement":"filter.minConfidence === undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":41,"line":141},"start":{"column":7,"line":141}}},{"id":"48","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":4,"line":143},"start":{"column":43,"line":141}}},{"id":"49","mutatorName":"MethodExpression","replacement":"results","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":73,"line":142},"start":{"column":15,"line":142}}},{"id":"50","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":72,"line":142},"start":{"column":30,"line":142}}},{"id":"51","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":72,"line":142},"start":{"column":35,"line":142}}},{"id":"52","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":72,"line":142},"start":{"column":35,"line":142}}},{"id":"53","mutatorName":"EqualityOperator","replacement":"o.confidence > filter.minConfidence!","status":"Survived","static":false,"testsCompleted":1,"coveredBy":["271"],"location":{"end":{"column":72,"line":142},"start":{"column":35,"line":142}}},{"id":"54","mutatorName":"EqualityOperator","replacement":"o.confidence < filter.minConfidence!","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["271"],"coveredBy":["271"],"location":{"end":{"column":72,"line":142},"start":{"column":35,"line":142}}},{"id":"55","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"Cannot read properties of undefined (reading 'every')","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":44,"line":146},"start":{"column":7,"line":146}}},{"id":"56","mutatorName":"ConditionalExpression","replacement":"false","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":4,"killedBy":["272"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":44,"line":146},"start":{"column":7,"line":146}}},{"id":"57","mutatorName":"LogicalOperator","replacement":"filter.tags || filter.tags.length > 0","statusReason":"Cannot read properties of undefined (reading 'length')","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":44,"line":146},"start":{"column":7,"line":146}}},{"id":"58","mutatorName":"ConditionalExpression","replacement":"true","status":"Survived","static":false,"testsCompleted":1,"coveredBy":["272"],"location":{"end":{"column":44,"line":146},"start":{"column":22,"line":146}}},{"id":"59","mutatorName":"EqualityOperator","replacement":"filter.tags.length >= 0","status":"Survived","static":false,"testsCompleted":1,"coveredBy":["272"],"location":{"end":{"column":44,"line":146},"start":{"column":22,"line":146}}},{"id":"60","mutatorName":"EqualityOperator","replacement":"filter.tags.length <= 0","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":44,"line":146},"start":{"column":22,"line":146}}},{"id":"61","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":4,"line":150},"start":{"column":46,"line":146}}},{"id":"62","mutatorName":"MethodExpression","replacement":"results","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":6,"line":149},"start":{"column":15,"line":147}}},{"id":"63","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":63,"line":148},"start":{"column":30,"line":147}}},{"id":"64","mutatorName":"MethodExpression","replacement":"filter.tags!.some(tag => o.metadata.tags.includes(tag))","statusReason":"expected [ { …(7) }, { …(7) } ] to have a length of 1 but got 2","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":63,"line":148},"start":{"column":7,"line":148}}},{"id":"65","mutatorName":"ArrowFunction","replacement":"() => undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":1,"killedBy":["272"],"coveredBy":["272"],"location":{"end":{"column":62,"line":148},"start":{"column":26,"line":148}}},{"id":"66","mutatorName":"ConditionalExpression","replacement":"true","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":33,"line":153},"start":{"column":7,"line":153}}},{"id":"67","mutatorName":"ConditionalExpression","replacement":"false","status":"Survived","static":false,"testsCompleted":4,"coveredBy":["270","271","272","273"],"location":{"end":{"column":33,"line":153},"start":{"column":7,"line":153}}},{"id":"68","mutatorName":"EqualityOperator","replacement":"filter.since === undefined","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":false,"testsCompleted":4,"killedBy":["270","271","272","273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":33,"line":153},"start":{"column":7,"line":153}}},{"id":"76","mutatorName":"MethodExpression","replacement":"results","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":false,"testsCompleted":4,"killedBy":["273"],"coveredBy":["270","271","272","273"],"location":{"end":{"column":40,"line":158},"start":{"column":10,"line":158}}},{"id":"77","mutatorName":"BlockStatement","replacement":"{}","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["258"],"coveredBy":["258"],"location":{"end":{"column":2,"line":171},"start":{"column":106,"line":164}}},{"id":"78","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":false,"testsCompleted":1,"killedBy":["258"],"coveredBy":["258"],"location":{"end":{"column":4,"line":170},"start":{"column":10,"line":165}}},{"id":"0","mutatorName":"ArrayDeclaration","replacement":"[]","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["257","258","274"],"coveredBy":[],"location":{"end":{"column":2,"line":23},"start":{"column":47,"line":15}}},{"id":"1","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["258","274"],"coveredBy":[],"location":{"end":{"column":11,"line":16},"start":{"column":3,"line":16}}},{"id":"2","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["257"],"coveredBy":[],"location":{"end":{"column":15,"line":17},"start":{"column":3,"line":17}}},{"id":"3","mutatorName":"StringLiteral","replacement":"\"\"","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["258"],"coveredBy":[],"location":{"end":{"column":10,"line":18},"start":{"column":3,"line":18}}},{"id":"4","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":14,"line":19},"start":{"column":3,"line":19}}},{"id":"5","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":11,"line":20},"start":{"column":3,"line":20}}},{"id":"6","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":16,"line":21},"start":{"column":3,"line":21}}},{"id":"7","mutatorName":"StringLiteral","replacement":"\"\"","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":14,"line":22},"start":{"column":3,"line":22}}},{"id":"8","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"expected true to be false // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["259"],"coveredBy":[],"location":{"end":{"column":2,"line":41},"start":{"column":43,"line":29}}},{"id":"9","mutatorName":"MethodExpression","replacement":"z.number().min(0).min(1)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["257","259"],"coveredBy":[],"location":{"end":{"column":39,"line":35},"start":{"column":15,"line":35}}},{"id":"10","mutatorName":"MethodExpression","replacement":"z.number().max(0)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["257","258"],"coveredBy":[],"location":{"end":{"column":32,"line":35},"start":{"column":15,"line":35}}},{"id":"11","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":4,"line":40},"start":{"column":22,"line":36}}},{"id":"12","mutatorName":"MethodExpression","replacement":"z.number().max(0)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["257"],"coveredBy":[],"location":{"end":{"column":33,"line":37},"start":{"column":16,"line":37}}},{"id":"13","mutatorName":"ArrayDeclaration","replacement":"[\"Stryker was here\"]","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":41,"line":39},"start":{"column":39,"line":39}}},{"id":"14","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":2,"line":52},"start":{"column":48,"line":47}}},{"id":"15","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":2,"line":63},"start":{"column":43,"line":58}}},{"id":"16","mutatorName":"BooleanLiteral","replacement":"true","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":39,"line":62},"start":{"column":34,"line":62}}},{"id":"17","mutatorName":"ObjectLiteral","replacement":"{}","status":"Survived","static":true,"testsCompleted":339,"coveredBy":[],"location":{"end":{"column":2,"line":75},"start":{"column":49,"line":69}}},{"id":"18","mutatorName":"MethodExpression","replacement":"z.number().min(0).min(1)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["274"],"coveredBy":[],"location":{"end":{"column":42,"line":71},"start":{"column":18,"line":71}}},{"id":"19","mutatorName":"MethodExpression","replacement":"z.number().max(0)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["274"],"coveredBy":[],"location":{"end":{"column":35,"line":71},"start":{"column":18,"line":71}}},{"id":"20","mutatorName":"MethodExpression","replacement":"z.number().int().min(1).min(1000)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["274"],"coveredBy":[],"location":{"end":{"column":43,"line":74},"start":{"column":10,"line":74}}},{"id":"21","mutatorName":"MethodExpression","replacement":"z.number().int().max(1)","statusReason":"expected false to be true // Object.is equality","status":"Killed","static":true,"testsCompleted":339,"killedBy":["274"],"coveredBy":[],"location":{"end":{"column":33,"line":74},"start":{"column":10,"line":74}}},{"id":"24","mutatorName":"BlockStatement","replacement":"{}","statusReason":"Cannot read properties of undefined (reading 'id')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","257","258","259","270","271","272"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":2,"line":127},"start":{"column":16,"line":113}}},{"id":"25","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":".toMatch() expects to receive a string, but got undefined","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","257","258","259","270","271","272"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":4,"line":126},"start":{"column":10,"line":114}}},{"id":"26","mutatorName":"OptionalChaining","replacement":"options.query","statusReason":"Cannot read properties of undefined (reading 'query')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","258"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":26,"line":118},"start":{"column":12,"line":118}}},{"id":"27","mutatorName":"LogicalOperator","replacement":"options?.confidence && 1","statusReason":"expected [ { …(7) }, { …(7) }, { …(7) }, …(1) ] to have a length of 2 but got 4","status":"Killed","static":true,"testsCompleted":339,"killedBy":["271"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":41,"line":120},"start":{"column":17,"line":120}}},{"id":"28","mutatorName":"OptionalChaining","replacement":"options.confidence","statusReason":"Cannot read properties of undefined (reading 'confidence')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","258"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":36,"line":120},"start":{"column":17,"line":120}}},{"id":"29","mutatorName":"ObjectLiteral","replacement":"{}","statusReason":"Cannot read properties of undefined (reading 'includes')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["272"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":6,"line":125},"start":{"column":15,"line":121}}},{"id":"30","mutatorName":"OptionalChaining","replacement":"options.latencyMs","statusReason":"Cannot read properties of undefined (reading 'latencyMs')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","258"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":36,"line":122},"start":{"column":18,"line":122}}},{"id":"31","mutatorName":"OptionalChaining","replacement":"options.sourceUrl","statusReason":"Cannot read properties of undefined (reading 'sourceUrl')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","258"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":36,"line":123},"start":{"column":18,"line":123}}},{"id":"32","mutatorName":"LogicalOperator","replacement":"options?.tags && []","statusReason":"expected [] to have a length of 2 but got +0","status":"Killed","static":true,"testsCompleted":339,"killedBy":["272"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":32,"line":124},"start":{"column":13,"line":124}}},{"id":"33","mutatorName":"OptionalChaining","replacement":"options.tags","statusReason":"Cannot read properties of undefined (reading 'tags')","status":"Killed","static":true,"testsCompleted":339,"killedBy":["255","256","258"],"coveredBy":["255","256","257","258","259"],"location":{"end":{"column":26,"line":124},"start":{"column":13,"line":124}}}],"source":"/**\r\n * P0 LIDLESS LEGION - Zod Contracts\r\n * \r\n * @port 0\r\n * @commander LIDLESS_LEGION\r\n * @verb OBSERVE / SENSE\r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Requirements 2.1, 2.2, 2.3, 2.4, 2.5, 2.6, 2.7\r\n */\r\n\r\nimport { z } from 'zod';\r\n\r\n// --- OBSERVATION SOURCE ---\r\n\r\nexport const ObservationSourceSchema = z.enum([\r\n  'TAVILY',      // Web search\r\n  'PERPLEXITY',  // AI search\r\n  'OSINT',       // Open source intelligence\r\n  'MEDIAPIPE',   // Gesture recognition\r\n  'WEBCAM',      // Raw video input\r\n  'FILE_SYSTEM', // Local file observation\r\n  'STIGMERGY',   // Blackboard observation\r\n]);\r\n\r\nexport type ObservationSource = z.infer<typeof ObservationSourceSchema>;\r\n\r\n// --- OBSERVATION SCHEMA ---\r\n\r\nexport const ObservationSchema = z.object({\r\n  id: z.string().uuid(),\r\n  timestamp: z.number(),\r\n  source: ObservationSourceSchema,\r\n  query: z.string().optional(),\r\n  data: z.unknown(),\r\n  confidence: z.number().min(0).max(1).default(1),\r\n  metadata: z.object({\r\n    latencyMs: z.number().min(0).optional(),\r\n    sourceUrl: z.string().url().optional(),\r\n    tags: z.array(z.string()).default([]),\r\n  }),\r\n});\r\n\r\nexport type Observation = z.infer<typeof ObservationSchema>;\r\n\r\n// --- OBSERVATION BATCH ---\r\n\r\nexport const ObservationBatchSchema = z.object({\r\n  id: z.string().uuid(),\r\n  timestamp: z.number(),\r\n  observations: z.array(ObservationSchema),\r\n  correlationId: z.string().optional(),\r\n});\r\n\r\nexport type ObservationBatch = z.infer<typeof ObservationBatchSchema>;\r\n\r\n// --- SENSE RESULT ---\r\n\r\nexport const SenseResultSchema = z.object({\r\n  success: z.boolean(),\r\n  observation: ObservationSchema.optional(),\r\n  error: z.string().optional(),\r\n  retryable: z.boolean().default(false),\r\n});\r\n\r\nexport type SenseResult = z.infer<typeof SenseResultSchema>;\r\n\r\n// --- OBSERVATION FILTER ---\r\n\r\nexport const ObservationFilterSchema = z.object({\r\n  sources: z.array(ObservationSourceSchema).optional(),\r\n  minConfidence: z.number().min(0).max(1).optional(),\r\n  tags: z.array(z.string()).optional(),\r\n  since: z.number().optional(),\r\n  limit: z.number().int().min(1).max(1000).default(100),\r\n});\r\n\r\nexport type ObservationFilter = z.infer<typeof ObservationFilterSchema>;\r\n\r\n// --- VERB ENFORCEMENT ---\r\n\r\nconst ALLOWED_VERBS = ['OBSERVE', 'SENSE'] as const;\r\nconst FORBIDDEN_VERBS = ['SHAPE', 'STORE', 'DECIDE', 'INJECT', 'DISRUPT', 'IMMUNIZE', 'BRIDGE', 'ASSIMILATE'] as const;\r\n\r\n/**\r\n * Validates that P0 only uses allowed verbs (separation of concerns)\r\n */\r\nexport function isAllowedVerb(verb: string): boolean {\r\n  return (ALLOWED_VERBS as readonly string[]).includes(verb);\r\n}\r\n\r\n/**\r\n * Checks if a verb is forbidden for P0\r\n */\r\nexport function isForbiddenVerb(verb: string): boolean {\r\n  return (FORBIDDEN_VERBS as readonly string[]).includes(verb);\r\n}\r\n\r\n// --- OBSERVATION FUNCTIONS ---\r\n\r\n/**\r\n * Creates a new observation\r\n */\r\nexport function createObservation(\r\n  source: ObservationSource,\r\n  data: unknown,\r\n  options?: {\r\n    query?: string;\r\n    confidence?: number;\r\n    latencyMs?: number;\r\n    sourceUrl?: string;\r\n    tags?: string[];\r\n  }\r\n): Observation {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    timestamp: Date.now(),\r\n    source,\r\n    query: options?.query,\r\n    data,\r\n    confidence: options?.confidence ?? 1,\r\n    metadata: {\r\n      latencyMs: options?.latencyMs,\r\n      sourceUrl: options?.sourceUrl,\r\n      tags: options?.tags ?? [],\r\n    },\r\n  };\r\n}\r\n\r\n/**\r\n * Filters observations based on criteria\r\n */\r\nexport function filterObservations(observations: Observation[], filter: ObservationFilter): Observation[] {\r\n  let results = observations;\r\n  \r\n  // Filter by source\r\n  if (filter.sources && filter.sources.length > 0) {\r\n    results = results.filter(o => filter.sources!.includes(o.source));\r\n  }\r\n  \r\n  // Filter by confidence\r\n  if (filter.minConfidence !== undefined) {\r\n    results = results.filter(o => o.confidence >= filter.minConfidence!);\r\n  }\r\n  \r\n  // Filter by tags\r\n  if (filter.tags && filter.tags.length > 0) {\r\n    results = results.filter(o => \r\n      filter.tags!.every(tag => o.metadata.tags.includes(tag))\r\n    );\r\n  }\r\n  \r\n  // Filter by timestamp\r\n  if (filter.since !== undefined) {\r\n    results = results.filter(o => o.timestamp >= filter.since!);\r\n  }\r\n  \r\n  // Apply limit\r\n  return results.slice(0, filter.limit);\r\n}\r\n\r\n/**\r\n * Merges multiple observations into a batch\r\n */\r\nexport function batchObservations(observations: Observation[], correlationId?: string): ObservationBatch {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    timestamp: Date.now(),\r\n    observations,\r\n    correlationId,\r\n  };\r\n}\r\n"}},"schemaVersion":"1.0","thresholds":{"high":80,"low":60,"break":null},"testFiles":{"hot_obsidian_sandbox/bronze/P4_RED_REGNANT/RED_REGNANT.test.ts":{"tests":[{"id":"0","name":"Red Regnant: Immunological Defense (Lockdown Suite) Environment & Scream Protocol (Killing Core mutants) should have non-negotiable environments"},{"id":"1","name":"Red Regnant: Immunological Defense (Lockdown Suite) Environment & Scream Protocol (Killing Core mutants) should handle non-string files in scream (Killing Ternary mutants)"},{"id":"2","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should allow debug logs with @permitted"},{"id":"3","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should allow any with @bespoke"},{"id":"4","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should handle mutation report parse failures"},{"id":"5","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should handle missing mutation report"},{"id":"6","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect TODO and FIXME"},{"id":"7","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect console.debug in strict zones"},{"id":"8","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect PHANTOM dependencies in index.html"},{"id":"9","name":"Red Regnant: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect BDD_MISALIGNMENT in strict zones"},{"id":"10","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should match violation messages exactly"},{"id":"11","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should verify mutation score boundary conditions"},{"id":"12","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should handle non-number mutation score"},{"id":"13","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect unauthorized debug logs correctly"},{"id":"14","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect bespoke any correctly"},{"id":"15","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect violations in special zones"},{"id":"16","name":"Red Regnant: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should kill mutants in ALLOWED_ROOT_FILES list by process of exclusion"},{"id":"17","name":"Red Regnant: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate Manifest and block invalid DNA"},{"id":"18","name":"Red Regnant: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate Playbook format (Killing literal mutants)"},{"id":"19","name":"Red Regnant: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate BloodBook entry"},{"id":"20","name":"Red Regnant: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should detect unauthorized files"},{"id":"21","name":"Red Regnant: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should kill mutants that weaken regex patterns"},{"id":"22","name":"Red Regnant: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should handle the logical OR between list and patterns"},{"id":"23","name":"Red Regnant: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should detect technical debt and strict zone violations"},{"id":"24","name":"Red Regnant: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should detect assertionless tests"},{"id":"25","name":"Red Regnant: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should allow tests with either expect or assert"},{"id":"26","name":"Red Regnant: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should detect WEAK_EVOLUTION (Killing NoCoverage & boundaries)"},{"id":"27","name":"Red Regnant: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should detect THEATER (Killing String/Math/Boundary mutants)"},{"id":"28","name":"Red Regnant: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should handle missing mutation report gracefully"},{"id":"29","name":"Red Regnant: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should handle malformed JSON in mutation report"},{"id":"30","name":"Red Regnant: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should handle Timeout as Killed"},{"id":"31","name":"Red Regnant: Immunological Defense (Lockdown Suite) Galois Lattice Governance (Port 4/Port 2) should detect Hive Bloat when folder density exceeds LATTICE.O4 (4096) for Bronze"},{"id":"32","name":"Red Regnant: Immunological Defense (Lockdown Suite) Galois Lattice Governance (Port 4/Port 2) should report correct folder in Hive Bloat violation"},{"id":"33","name":"Red Regnant: Immunological Defense (Lockdown Suite) Galois Lattice Governance (Port 4/Port 2) should pass if folder density is exactly LATTICE.O4 (4096) for Bronze"},{"id":"34","name":"Red Regnant: Immunological Defense (Lockdown Suite) Galois Lattice Governance (Port 4/Port 2) should fail if Silver folder density exceeds LATTICE.SWARM (64)"},{"id":"35","name":"Red Regnant: Immunological Defense (Lockdown Suite) Galois Lattice Governance (Port 4/Port 2) should skip non-existent folders in lattice check"},{"id":"36","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should recurse subdirectories and detect missing tests"},{"id":"37","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should audit .js and .md files in medallions"},{"id":"38","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should skip non-standard file extensions in medallions"},{"id":"39","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should explicitly skip .d.ts files (Killing d.ts mutant)"},{"id":"40","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should handle property tests as valid tests (Killing .property.ts mutant)"},{"id":"41","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should skip restricted directories like node_modules and .venv (Killing exclusion mutants)"},{"id":"42","name":"Red Regnant: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should distinguish between strict (silver/gold) and non-strict (bronze) zones (Killing isStrict mutant)"},{"id":"43","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Error Handling should handle readFileSync errors in scanMedallions gracefully"},{"id":"44","name":"Red Regnant: Immunological Defense (Lockdown Suite) Lockdown Execution should return violations for enforcement (H-I behavior)"},{"id":"45","name":"Red Regnant: Immunological Defense (Lockdown Suite) Lockdown Execution should return success if no violations exist"},{"id":"46","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Behavioral Suspicion (Killing NoCoverage mutants) should detect silent catch blocks (OMISSION)"},{"id":"47","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Behavioral Suspicion (Killing NoCoverage mutants) should detect manual bypasses (SUSPICION)"},{"id":"48","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Behavioral Suspicion (Killing NoCoverage mutants) should detect alternative bypass patterns"},{"id":"49","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill regex boundary mutants in scanMedallions"},{"id":"50","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill the regex spacing mutant for \"any\""},{"id":"51","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill individual condition mutants in PHANTOM dependency check"},{"id":"52","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill the mutation score math mutants"},{"id":"53","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill the replacement mutants in scanMedallions (testPath vs propertyPath)"},{"id":"54","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill root pattern boundary mutants (Killing ^ and $)"},{"id":"55","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill the ALLOWED_ROOT_FILES mutants"},{"id":"56","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should kill isStrict logic mutants"},{"id":"57","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Mutant Hunting (Port 4 Final) should handle Semgrep missing venv (Killing Semgrep survivors)"},{"id":"58","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should format console output correctly when not in test mode"},{"id":"59","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should NOT format console output when in test mode"},{"id":"60","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should handle non-string file objects in scream"},{"id":"61","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should return quickly if root directory is missing"},{"id":"62","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should kill mutants in ALLOWED_ROOT_FILES list by process of exclusion"},{"id":"63","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Terminal & Environment (Killing Survivours) should kill mutants in ALLOWED_ROOT_PATTERNS list"},{"id":"64","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in content.includes chains by exhaustive checking"},{"id":"65","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in scanMedallions iteration logic"},{"id":"66","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in isStrict logic for P5 exceptions"},{"id":"67","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in checkMutationProof score calculation"},{"id":"68","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants that weaken regex patterns in scanMedallions"},{"id":"69","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill individual logical operator mutants in phantom check"},{"id":"70","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill survivors in scream and console formatting"},{"id":"71","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in Galois Lattice constants"},{"id":"72","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in ALLOWED_ROOT_FILES by exhaustive check"},{"id":"73","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in checkMutationProof score comparisons"},{"id":"74","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should handle Timeout as Killed in score calculation"},{"id":"75","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutants in auditContent multi-condition checks"},{"id":"76","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill scanMedallions iteration logic mutants"},{"id":"77","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutation score math mutants"},{"id":"78","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should kill mutation threshold boundary exactly"},{"id":"79","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should persist violations to DuckDB (Kraken Store)"},{"id":"80","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) should handle empty violations list in Kraken store"},{"id":"81","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill isBronze toUpperCase mutant"},{"id":"82","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill TODO/FIXME string literal mutants"},{"id":"83","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill scanMedallions directory exclusion mutants"},{"id":"84","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill scream file parameter normalization mutants"},{"id":"85","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill mutation score comparison boundary (Killing < vs <=)"},{"id":"86","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill isStrict zone detection mutants"},{"id":"87","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should hit Semgrep audit and parse issues"},{"id":"88","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should handle Semgrep errors with stdout payload"},{"id":"89","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should audit Silver Shroud with Zod logic"},{"id":"90","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should analyze suspicion via empty catch blocks"},{"id":"91","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should analyze suspicion via ignore markers"},{"id":"92","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should detect AI theater overloads (Port 4 Surgical Kill)"},{"id":"93","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should detect mocks in non-test strict files"},{"id":"94","name":"Red Regnant: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (Gen 88 Pareto) Final Surgical Kills (Gen 88 Pareto) should kill regex mutants in placeholder detection"}],"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\r\nimport * as fs from 'node:fs';\r\nimport * as path from 'node:path';\r\nimport * as child_process from 'node:child_process';\r\n\r\nvi.mock('node:child_process', () => ({\r\n    execSync: vi.fn(),\r\n}));\r\n\r\n// Set test mode before importing the module using vi.hoisted to beat ESM hoisting\r\nvi.hoisted(() => {\r\n    process.env.HFO_TEST_MODE = 'true';\r\n});\r\n\r\nimport { \r\n    checkRootPollution, \r\n    checkMutationProof, \r\n    auditContent,\r\n    scanMedallions,\r\n    performScreamAudit,\r\n    runSemgrepAudit,\r\n    checkLatticeHealth,\r\n    checkSilverShroud,\r\n    analyzeSuspicion,\r\n    persistToKraken,\r\n    violations,\r\n    clearViolations,\r\n    scream,\r\n    ALLOWED_ROOT_FILES,\r\n    ALLOWED_ROOT_PATTERNS,\r\n    ROOT_DIR,\r\n    BRONZE_DIR,\r\n    HOT_DIR,\r\n    COLD_DIR,\r\n    LATTICE,\r\n    CacaoPlaybookSchema,\r\n    BloodBookEntrySchema,\r\n    ManifestSchema\r\n} from './RED_REGNANT.js';\r\n\r\nvi.mock('node:fs');\r\n\r\nconst mockDirEnt = (name: string, isDir = false) => ({ name, isDirectory: () => isDir } as any);\r\n\r\ndescribe('Red Regnant: Immunological Defense (Lockdown Suite)', () => {\r\n    beforeEach(() => {\r\n        vi.resetAllMocks();\r\n        clearViolations();\r\n        vi.mocked(fs.existsSync).mockReturnValue(true);\r\n        vi.mocked(fs.readdirSync).mockReturnValue([]);\r\n        vi.mocked(fs.readFileSync).mockReturnValue('');\r\n        process.env.HFO_TEST_MODE = 'true';\r\n    });\r\n\r\n    describe('Environment & Scream Protocol (Killing Core mutants)', () => {\r\n        it('should have non-negotiable environments', () => {\r\n            expect(process.env.HFO_TEST_MODE).toBe('true');\r\n            expect(typeof ROOT_DIR).toBe('string');\r\n        });\r\n\r\n        it('should handle non-string files in scream (Killing Ternary mutants)', () => {\r\n            scream({ file: { name: 'object-file' } as any, type: 'AMNESIA', message: 'test' });\r\n            expect(violations[0].file).toBe('object-file');\r\n            \r\n            clearViolations();\r\n            scream({ file: 123 as any, type: 'AMNESIA', message: 'test' });\r\n            expect(violations[0].file).toBe('123');\r\n            \r\n            clearViolations();\r\n            scream({ file: null as any, type: 'AMNESIA', message: 'test' });\r\n            expect(violations[0].file).toBe('UNKNOWN');\r\n        });\r\n    });\r\n\r\n    describe('Additional Coverage (Pushing score to 80%+)', () => {\r\n        it('should allow debug logs with @permitted', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'console.log(\"test\"); // @permitted\\nProvenance: test');\r\n            expect(violations.find(v => v.type === 'AMNESIA')).toBeUndefined();\r\n        });\r\n\r\n        it('should allow any with @bespoke', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'const x: any = 1; // @bespoke\\nProvenance: test');\r\n            expect(violations.find(v => v.type === 'BESPOKE')).toBeUndefined();\r\n        });\r\n\r\n        it('should handle mutation report parse failures', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue('invalid json');\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n        });\r\n\r\n        it('should handle missing mutation report', () => {\r\n            const reportPath = path.join(BRONZE_DIR, 'infra/reports/mutation/mutation.json');\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => p !== reportPath);\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n        });\r\n        \r\n        it('should detect TODO and FIXME', () => {\r\n            auditContent('file.ts', '// TODO items');\r\n            expect(violations.some(v => v.type === 'AMNESIA' && v.message.includes('TODO/FIXME'))).toBe(true);\r\n            clearViolations();\r\n            auditContent('file.ts', '// FIXME items');\r\n            expect(violations.some(v => v.type === 'AMNESIA' && v.message.includes('TODO/FIXME'))).toBe(true);\r\n        });\r\n\r\n        it('should detect console.debug in strict zones', () => {\r\n            const strict = path.join(HOT_DIR, 'gold', 'logic.ts');\r\n            auditContent(strict, 'console.debug(\"test\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });\r\n\r\n        it('should detect PHANTOM dependencies in index.html', () => {\r\n            auditContent('index.html', '<script src=\"https://cdn.com/lib.js\"></script>');\r\n            expect(violations.find(v => v.type === 'PHANTOM')?.message).toContain('External CDN dependency detected in index.html.');\r\n            clearViolations();\r\n            auditContent('script.ts', 'fetch(\"http://cdn.com/api\")');\r\n            expect(violations.find(v => v.type === 'PHANTOM')).toBeDefined();\r\n        });\r\n\r\n        it('should detect BDD_MISALIGNMENT in strict zones', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            // Missing Validates or @provenance\r\n            auditContent(strict, 'Provenance: test\\nconst x = 1;');\r\n            expect(violations.find(v => v.type === 'BDD_MISALIGNMENT')?.message).toBe('Implementation file missing requirement traceability (Validates: or @provenance).');\r\n            \r\n            clearViolations();\r\n            // Has Validates\r\n            auditContent(strict, 'Provenance: test\\n// Validates: Req1');\r\n            expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('Strict Coverage (Killing Exact String Mutants)', () => {\r\n        it('should match violation messages exactly', () => {\r\n            auditContent('file.ts', '// TODO');\r\n            expect(violations[0].message).toContain('AI SLOP: Technical debt (TODO/FIXME) detected.');\r\n            clearViolations();\r\n            \r\n            vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'POISON.exe', isDirectory: () => false }] as any);\r\n            checkRootPollution();\r\n            const badFile = violations.find(v => v.type === 'POLLUTION');\r\n            if (badFile) {\r\n                expect(badFile.message).toBe('Unauthorized root file detected.');\r\n            }\r\n        });\r\n\r\n        it('should verify mutation score boundary conditions', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 88 }\r\n             }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n\r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 87.9 }\r\n             }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n             \r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 99 }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n        });\r\n\r\n        it('should handle non-number mutation score', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: \"100\" }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.find(v => v.message === 'Invalid score format in metrics.')).toBeDefined();\r\n        });\r\n        \r\n        it('should detect unauthorized debug logs correctly', () => {\r\n             const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n             auditContent(strict, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.find(v => v.type === 'AMNESIA')?.message).toBe('Unauthorized debug logs in strict zone: true.');\r\n        });\r\n\r\n        it('should detect bespoke any correctly', () => {\r\n             const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n             auditContent(strict, 'let x: any;\\nProvenance: test');\r\n             expect(violations.find(v => v.type === 'BESPOKE')?.message).toBe('Bespoke \"any\" type without justification (@bespoke).');\r\n        });\r\n        it('should detect violations in special zones', () => {\r\n             const areaPath = path.join(HOT_DIR, '2_areas', 'logic.ts');\r\n             auditContent(areaPath, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n\r\n             clearViolations();\r\n             const goldPath = path.join(HOT_DIR, 'gold', 'logic.ts');\r\n             auditContent(goldPath, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });        \r\n        it('should kill mutants in ALLOWED_ROOT_FILES list by process of exclusion', () => {\r\n            // We can't easily mutate the constant in the test, \r\n            // but we can ensure every entry in ALLOWED_ROOT_FILES is actually used \r\n            // if we were to mock readdir results for each.\r\n            // But checking ALL of them is tedious. Let's do a few key ones.\r\n            const important = ['package.json', 'stryker.root.config.mjs', 'vitest.root.config.ts', '.gitignore'];\r\n            important.forEach(file => {\r\n                vi.mocked(fs.readdirSync).mockReturnValue([{ name: file, isDirectory: () => false }] as any);\r\n                checkRootPollution();\r\n                expect(violations).toHaveLength(0);\r\n                clearViolations();\r\n            });\r\n        });\r\n    });\r\n\r\n    describe('Schemas & Data Integrity (Killing Zod mutants)', () => {\r\n        it('should validate Manifest and block invalid DNA', () => {\r\n            const valid = {\r\n                identity: { port: 4, commander: 'Red' },\r\n                galois_lattice: { coordinate: [1, 1] },\r\n                dna: { hfo_generation: 88 }\r\n            };\r\n            expect(ManifestSchema.parse(valid)).toMatchObject(valid);\r\n            expect(() => ManifestSchema.parse({ ...valid, identity: { port: '4' } as any })).toThrow();\r\n            expect(() => ManifestSchema.parse({ ...valid, galois_lattice: { coordinate: [1] } })).toThrow();\r\n        });\r\n\r\n        it('should validate Playbook format (Killing literal mutants)', () => {\r\n            const pb = { type: 'playbook', id: 'playbook--1', name: 'N', description: 'D', steps: [{ type: 'T', name: 'N', description: 'D' }] };\r\n            expect(CacaoPlaybookSchema.parse(pb)).toMatchObject(pb);\r\n            \r\n            // Negative ID check\r\n            expect(() => CacaoPlaybookSchema.parse({ ...pb, id: 'pb-1' })).toThrow();\r\n            \r\n            expect(() => CacaoPlaybookSchema.parse({ ...pb, steps: [{ name: 'N' }] as any })).toThrow();\r\n        });\r\n\r\n        it('should validate BloodBook entry', () => {\r\n            const entry = {\r\n                index: 1,\r\n                ts: '2026-01-01',\r\n                artifact_id: 'A',\r\n                resonance_signature: 'S',\r\n                prev_hash: '0',\r\n                hash: 'H'\r\n            };\r\n            expect(BloodBookEntrySchema.parse(entry)).toMatchObject(entry);\r\n            expect(() => BloodBookEntrySchema.parse({ ...entry, index: '1' } as any)).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Root Pollution (Killing Regex & List mutants)', () => {\r\n        it('should detect unauthorized files', () => {\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('POISON.exe')] as any);\r\n            checkRootPollution();\r\n            expect(violations.some(v => v.type === 'POLLUTION')).toBe(true);\r\n        });\r\n\r\n        it('should kill mutants that weaken regex patterns', () => {\r\n            // Test that startsWith and endsWith are enforced (^ and $)\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('OLD-ttao-notes-2026.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-2026.md.bak')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('PREFIX.vitest.config.ts')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-2026.txt')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n            \r\n            // Test vitest prefix\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('vitest.logic.ts')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0); // Allowed by pattern /^vitest\\..*$/\r\n        });\r\n\r\n        it('should handle the logical OR between list and patterns', () => {\r\n            // Case 1: In list, not in patterns\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('AGENTS.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0);\r\n            clearViolations();\r\n\r\n            // Case 2: Not in list, matches pattern\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-reboot.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0);\r\n            clearViolations();\r\n        });\r\n    });\r\n\r\n    describe('Content Auditing (Killing Audit mutants)', () => {\r\n        it('should detect technical debt and strict zone violations', () => {\r\n            auditContent('file.ts', '// TODO: fix');\r\n            expect(violations[0].type).toBe('AMNESIA');\r\n            expect(violations[0].message).toContain('AI SLOP: Technical debt (TODO/FIXME) detected.');\r\n\r\n            clearViolations();\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'const x: any = 1;');\r\n            expect(violations.some(v => v.type === 'BESPOKE')).toBe(true);\r\n            expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(true);\r\n        });\r\n\r\n        it('should detect assertionless tests', () => {\r\n            auditContent('test.test.ts', 'it(\"runs\", () => {})');\r\n            expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n        });\r\n\r\n        it('should allow tests with either expect or assert', () => {\r\n             auditContent('test.test.ts', 'it(\"t\", () => { expect(1).toBe(1); })');\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n             \r\n             clearViolations();\r\n             auditContent('test.test.ts', 'it(\"t\", () => { assert.equal(1, 1); })');\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('Mutation Proof Auditing (Killing Mutation Logic mutants)', () => {\r\n        it('should detect WEAK_EVOLUTION (Killing NoCoverage & boundaries)', () => {\r\n            // Test boundary 88.00 (Gen 88 Pareto)\r\n            const report88 = { metrics: { mutationScore: 88.00 } };\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report88));\r\n            checkMutationProof(88);\r\n            expect(violations).toHaveLength(0);\r\n\r\n            // Test boundary 87.99\r\n            const report87 = { metrics: { mutationScore: 87.99 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report87));\r\n            checkMutationProof(88);\r\n            expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n            \r\n            clearViolations();\r\n            const reportFiles = {\r\n                files: { 'bad.ts': { mutants: [{ status: 'Killed' }, { status: 'Survived' }] } }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(reportFiles));\r\n            checkMutationProof(88);\r\n            expect(violations[0].type).toBe('MUTATION_FAILURE');\r\n            expect(violations[0].message).toContain('50.00%');\r\n        });\r\n\r\n        it('should detect THEATER (Killing String/Math/Boundary mutants)', () => {\r\n            // Test non-number score\r\n            const reportNan = { metrics: { mutationScore: '100' } };\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(reportNan));\r\n            checkMutationProof(88);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Exact 99.00 should trigger THEATER\r\n            const report99 = { metrics: { mutationScore: 99.00 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report99));\r\n            checkMutationProof(88);\r\n            expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n\r\n            clearViolations();\r\n            // 98.88 should NOT trigger THEATER (Edge case)\r\n            const report9888 = { metrics: { mutationScore: 98.88 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report9888));\r\n            checkMutationProof(88);\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n\r\n        it('should handle missing mutation report gracefully', () => {\r\n            const reportPath = path.join(BRONZE_DIR, 'infra/reports/mutation/mutation.json');\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => p !== reportPath);\r\n            checkMutationProof(88);\r\n            const v = violations.find(v => v.type === 'MUTATION_GAP');\r\n            expect(v).toBeDefined();\r\n            expect(v?.message).toBe('Mutation report missing. Cleanroom integrity cannot be verified.');\r\n        });\r\n\r\n        it('should handle malformed JSON in mutation report', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue('invalid json');\r\n            checkMutationProof(88);\r\n            const v = violations.find(v => v.type === 'MUTATION_GAP');\r\n            expect(v).toBeDefined();\r\n            expect(v?.message).toBe('Failed to parse mutation report. Corruption suspected.');\r\n        });\r\n\r\n        it('should handle Timeout as Killed', () => {\r\n            const report = {\r\n                files: { 'ok.ts': { mutants: [{ status: 'Timeout' }] } }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report));\r\n            checkMutationProof(88);\r\n            // 1 mutant (Timeout) / 1 total = 100%. 100% is fine for single files.\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n    });\r\n\r\n    describe('Galois Lattice Governance (Port 4/Port 2)', () => {\r\n        it('should detect Hive Bloat when folder density exceeds LATTICE.O4 (4096) for Bronze', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                const target = BRONZE_DIR.toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === target) return new Array(4097).fill(null).map(() => mockDirEnt('file.ts'));\r\n                return [];\r\n            });\r\n            \r\n            checkLatticeHealth();\r\n            \r\n            expect(violations.some(v => v.message.includes('Hive Bloat'))).toBe(true);\r\n            expect(violations.some(v => v.message.includes('exceeds O4 Limit'))).toBe(true);\r\n        });\r\n\r\n        it('should report correct folder in Hive Bloat violation', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                const target = BRONZE_DIR.toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === target) return new Array(4097).fill(null).map(() => mockDirEnt('f.ts'));\r\n                return [];\r\n            });\r\n            const relBronze = path.relative(ROOT_DIR, BRONZE_DIR).toLowerCase().replace(/\\\\/g, '/');\r\n            checkLatticeHealth();\r\n            expect(violations.find(v => v.file.toLowerCase().replace(/\\\\/g, '/') === relBronze)).toBeDefined();\r\n        });\r\n\r\n        it('should pass if folder density is exactly LATTICE.O4 (4096) for Bronze', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                const target = BRONZE_DIR.toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === target) return new Array(4096).fill(null).map(() => mockDirEnt('file.ts'));\r\n                return [];\r\n            });\r\n            checkLatticeHealth();\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n        \r\n        it('should fail if Silver folder density exceeds LATTICE.SWARM (64)', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                const target = path.join(HOT_DIR, 'silver').toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === target) return new Array(65).fill(null).map(() => mockDirEnt('file.ts'));\r\n                return [];\r\n            });\r\n            \r\n            checkLatticeHealth();\r\n            expect(violations.some(v => v.message.includes('Hive Bloat'))).toBe(true);\r\n        });\r\n        \r\n        it('should skip non-existent folders in lattice check', () => {\r\n            vi.mocked(fs.existsSync).mockImplementation(p => p !== path.join(HOT_DIR, 'silver'));\r\n            vi.mocked(fs.readdirSync).mockReturnValue([]);\r\n            \r\n            checkLatticeHealth();\r\n            // Should not check readdir for silver\r\n            const silverCall = vi.mocked(fs.readdirSync).mock.calls.find(call => call[0] === path.join(HOT_DIR, 'silver'));\r\n            expect(silverCall).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('Medallion Scanning (Killing Loop & skip mutants)', () => {\r\n        const targetFolders = [\r\n            path.join(HOT_DIR, 'bronze'),\r\n            path.join(HOT_DIR, 'silver'),\r\n            path.join(HOT_DIR, 'gold'),\r\n            path.join(COLD_DIR, 'bronze'),\r\n            path.join(COLD_DIR, 'silver'),\r\n            path.join(COLD_DIR, 'gold')\r\n        ].map(p => p.toLowerCase().replace(/\\\\/g, '/'));\r\n\r\n        it('should recurse subdirectories and detect missing tests', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockSub = path.join(mockSilver, 'feature');\r\n            const mockLogic = path.join(mockSub, 'logic.ts');\r\n            const mockTest = path.join(mockSub, 'logic.test.ts');\r\n\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockSilver.toLowerCase().replace(/\\\\/g, '/') || \r\n                    sp === mockSub.toLowerCase().replace(/\\\\/g, '/') || \r\n                    sp === mockLogic.toLowerCase().replace(/\\\\/g, '/')) return true;\r\n                if (sp === mockTest.toLowerCase().replace(/\\\\/g, '/')) return false; // MISSING TEST\r\n                return false;\r\n            });\r\n\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockSilver.toLowerCase().replace(/\\\\/g, '/')) return [mockDirEnt('feature', true)] as any;\r\n                if (sp === mockSub.toLowerCase().replace(/\\\\/g, '/')) return [mockDirEnt('logic.ts', false)] as any;\r\n                return [];\r\n            });\r\n\r\n            scanMedallions();\r\n            expect(violations.some(v => v.type === 'THEATER' && v.message.includes('missing test'))).toBe(true);\r\n        });\r\n\r\n        it('should audit .js and .md files in medallions', () => {\r\n            const mockGold = path.join(HOT_DIR, 'gold');\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockGold.toLowerCase().replace(/\\\\/g, '/')) return [\r\n                    mockDirEnt('script.js'),\r\n                    mockDirEnt('doc.md')\r\n                ] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.readFileSync).mockReturnValue('// TODO: fix');\r\n\r\n            scanMedallions();\r\n            // Should audit both in gold, 2 violations (AMNESIA)\r\n            expect(violations.filter(v => v.type === 'AMNESIA')).toHaveLength(2);\r\n        });\r\n\r\n        it('should skip non-standard file extensions in medallions', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp.includes('gold')) return [mockDirEnt('image.png')] as any;\r\n                return [];\r\n            });\r\n            \r\n            scanMedallions();\r\n            // Should be called 0 times because image.png is skipped\r\n            expect(fs.readFileSync).not.toHaveBeenCalled();\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n\r\n        it('should explicitly skip .d.ts files (Killing d.ts mutant)', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockDts = path.join(mockSilver, 'types.d.ts');\r\n            \r\n            vi.mocked(fs.existsSync).mockImplementation(p => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                return sp === mockSilver.toLowerCase().replace(/\\\\/g, '/') || sp === mockDts.toLowerCase().replace(/\\\\/g, '/');\r\n            });\r\n            vi.mocked(fs.readdirSync).mockImplementation(p => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockSilver.toLowerCase().replace(/\\\\/g, '/')) return [mockDirEnt('types.d.ts', false)] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.readFileSync).mockReturnValue('// pure types');\r\n            \r\n            scanMedallions();\r\n            // Should not report missing test for d.ts (type: THEATER)\r\n            expect(violations.some(v => v.message.includes('missing test') && v.file.includes('types.d.ts'))).toBe(false);\r\n        });\r\n\r\n        it('should handle property tests as valid tests (Killing .property.ts mutant)', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockLogic = path.join(mockSilver, 'logic.ts').toLowerCase().replace(/\\\\/g, '/');\r\n            const mockProp = path.join(mockSilver, 'logic.property.ts').toLowerCase().replace(/\\\\/g, '/');\r\n\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockSilver.toLowerCase().replace(/\\\\/g, '/') || \r\n                    sp === mockLogic || sp === mockProp) return true;\r\n                return false;\r\n            });\r\n\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp === mockSilver.toLowerCase().replace(/\\\\/g, '/')) return [\r\n                    mockDirEnt('logic.ts', false),\r\n                    mockDirEnt('logic.property.ts', false)\r\n                ] as any;\r\n                return [];\r\n            });\r\n\r\n            scanMedallions();\r\n            // Should NOT report missing test because .property.ts exists\r\n            expect(violations.some(v => v.message.includes('missing test'))).toBe(false);\r\n        });\r\n\r\n        it('should skip restricted directories like node_modules and .venv (Killing exclusion mutants)', () => {\r\n             vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                // check if it's one of the base target folders (bronze/silver/gold)\r\n                if (targetFolders.includes(sp)) return [\r\n                    mockDirEnt('node_modules', true),\r\n                    mockDirEnt('.venv', true),\r\n                    mockDirEnt('.git', true),\r\n                    mockDirEnt('quarantine', true)\r\n                ] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            \r\n            scanMedallions();\r\n            // We want to ensure it doesn't even try to read them.\r\n            const readdirCalls = vi.mocked(fs.readdirSync).mock.calls.map(c => String(c[0]).toLowerCase().replace(/\\\\/g, '/'));\r\n            expect(readdirCalls.some(c => c.includes('node_modules'))).toBe(false);\r\n            expect(readdirCalls.some(c => c.includes('.venv'))).toBe(false);\r\n            expect(readdirCalls.some(c => c.includes('quarantine'))).toBe(false);\r\n        });\r\n\r\n        it('should distinguish between strict (silver/gold) and non-strict (bronze) zones (Killing isStrict mutant)', () => {\r\n            clearViolations();\r\n            \r\n            vi.mocked(fs.existsSync).mockImplementation(p => {\r\n                const sp = String(p).toLowerCase().replace(/\\\\/g, '/');\r\n                if (sp.includes('.test.ts') || sp.includes('.property.ts')) return false; // No tests\r\n                return true;\r\n            });\r\n            \r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                const sp = String(p).replace(/\\\\/g, '/');\r\n                if (sp.endsWith('/bronze')) return [mockDirEnt('b.ts', false)] as any;\r\n                if (sp.endsWith('/silver')) return [mockDirEnt('s.ts', false)] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.readFileSync).mockReturnValue('// code');\r\n\r\n            scanMedallions();\r\n            \r\n            // s.ts in silver should trigger missing test violation\r\n            // b.ts in bronze should NOT trigger missing test violation (non-strict)\r\n            const missingTests = violations.filter(v => v.message.toLowerCase().includes('missing test'));\r\n            const sViolation = missingTests.find(v => v.file.toLowerCase().replace(/\\\\/g, '/').includes('/s.ts'));\r\n            const bViolation = missingTests.find(v => v.file.toLowerCase().replace(/\\\\/g, '/').includes('/b.ts'));\r\n            \r\n            if (!sViolation) {\r\n                console.log('DEBUG: Violations:', JSON.stringify(violations, null, 2));\r\n                console.log('DEBUG: readdirSync calls:', vi.mocked(fs.readdirSync).mock.calls.map(c => c[0]));\r\n            }\r\n\r\n            expect(sViolation).toBeDefined();\r\n            expect(bViolation).toBeUndefined();\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Error Handling', () => {\r\n        it('should handle readFileSync errors in scanMedallions gracefully', () => {\r\n             vi.mocked(fs.existsSync).mockReturnValue(true);\r\n             vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'fail.ts', isDirectory: () => false }] as any);\r\n             vi.mocked(fs.readFileSync).mockImplementation(() => { throw new Error('Dead Disk'); });\r\n\r\n             expect(() => scanMedallions()).toThrow('Dead Disk');\r\n        });\r\n    });\r\n\r\n    describe('Lockdown Execution', () => {\r\n        it('should return violations for enforcement (H-I behavior)', async () => {\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                if (p === ROOT_DIR) return [\r\n                    { name: 'SYSTEM', isDirectory: () => false },\r\n                    { name: 'RED_REGNANT.ts', isDirectory: () => false },\r\n                    { name: 'TARGET.ts', isDirectory: () => false }\r\n                ] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue('{}');\r\n\r\n            const result = await performScreamAudit();\r\n            expect(result.success).toBe(false);\r\n            expect(result.violations.length).toBeGreaterThan(0);\r\n        });\r\n\r\n        it('should return success if no violations exist', async () => {\r\n             // Mock success\r\n             vi.mocked(fs.readdirSync).mockReturnValue([]);\r\n             vi.mocked(fs.existsSync).mockImplementation(p => String(p).includes('mutation.json'));\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 90 } }));\r\n             \r\n             const result = await performScreamAudit();\r\n             expect(result.success).toBe(true);\r\n             expect(result.violations).toHaveLength(0);\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Behavioral Suspicion (Killing NoCoverage mutants)', () => {\r\n        it('should detect silent catch blocks (OMISSION)', () => {\r\n            const content = 'try { doStuff(); } catch(e) {}';\r\n            auditContent('hot_obsidian_sandbox/silver/logic.ts', content);\r\n            const violation = violations.find(v => v.type === 'OMISSION');\r\n            expect(violation).toBeDefined();\r\n            expect(violation?.message).toContain('Silent catch block');\r\n        });\r\n\r\n        it('should detect manual bypasses (SUSPICION)', () => {\r\n            const content = 'const secret = 1; // @ignore-regnant';\r\n            auditContent('hot_obsidian_sandbox/silver/logic.ts', content);\r\n            const violation = violations.find(v => v.type === 'SUSPICION');\r\n            expect(violation).toBeDefined();\r\n            expect(violation?.message).toContain('Manual bypass detected');\r\n        });\r\n\r\n        it('should detect alternative bypass patterns', () => {\r\n            const content = '/* @bypass-praetorian */ function p() {}';\r\n            auditContent('hot_obsidian_sandbox/silver/logic.ts', content);\r\n            expect(violations.some(v => v.type === 'SUSPICION')).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Mutant Hunting (Port 4 Final)', () => {\r\n        it('should kill regex boundary mutants in scanMedallions', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockFakeTs = path.join(mockSilver, 'logic.ts.bak'); // Contains .ts but not at end\r\n            \r\n            vi.mocked(fs.existsSync).mockImplementation(p => {\r\n                const sp = String(p).replace(/\\\\/g, '/');\r\n                return sp.includes('silver');\r\n            });\r\n            vi.mocked(fs.readdirSync).mockImplementation(p => {\r\n                const sp = String(p).replace(/\\\\/g, '/');\r\n                if (sp.endsWith('/silver')) return [({ name: 'logic.ts.bak', isDirectory: () => false })] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.readFileSync).mockReturnValue('// content');\r\n            \r\n            scanMedallions();\r\n            // Should NOT scream about missing test for .ts.bak because it shouldn't match /\\.ts$/\r\n            expect(violations.some(v => v.message.includes('missing test'))).toBe(false);\r\n        });\r\n\r\n        it('should kill the regex spacing mutant for \"any\"', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            // Testing \":any\" (zero spaces) - should still match /:\\s*any/\r\n            auditContent(strict, 'const x:any = 1;\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'BESPOKE')).toBe(true);\r\n        });\r\n\r\n        it('should kill individual condition mutants in PHANTOM dependency check', () => {\r\n            // Test .html\r\n            auditContent('index.html', 'https://cdn.com/lib.js');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Test .ts\r\n            auditContent('logic.ts', 'https://cdn.com/lib.js');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Test .js\r\n            auditContent('script.js', 'https://cdn.com/lib.js');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n            clearViolations();\r\n            \r\n            // Test non-matching extension\r\n            auditContent('style.css', 'https://cdn.com/lib.js');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(false);\r\n        });\r\n\r\n        it('should kill the mutation score math mutants', () => {\r\n            // Test exact 88.00 (parity)\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 88.00 } }));\r\n            checkMutationProof(88);\r\n            expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n            \r\n            // Test total=0 skip in file-level check\r\n            clearViolations();\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                files: { 'empty.ts': { mutants: [] } }\r\n            }));\r\n            checkMutationProof(88);\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n\r\n        it('should kill the replacement mutants in scanMedallions (testPath vs propertyPath)', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockFile = path.join(mockSilver, 'core.ts');\r\n            \r\n            vi.mocked(fs.existsSync).mockImplementation(p => {\r\n                const sp = String(p).replace(/\\\\/g, '/');\r\n                if (sp.endsWith('/core.test.ts')) return false;\r\n                if (sp.endsWith('/core.property.ts')) return true; // Property test exists\r\n                return true;\r\n            });\r\n            vi.mocked(fs.readdirSync).mockImplementation(p => {\r\n                const sp = String(p).replace(/\\\\/g, '/');\r\n                if (sp.endsWith('/silver')) return [({ name: 'core.ts', isDirectory: () => false })] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.readFileSync).mockReturnValue('// content');\r\n\r\n            scanMedallions();\r\n            // Should NOT scream because property test exists\r\n            expect(violations.some(v => v.message.includes('missing test'))).toBe(false);\r\n        });\r\n\r\n        it('should kill root pattern boundary mutants (Killing ^ and $)', () => {\r\n            vi.mocked(fs.readdirSync).mockReturnValue(['UNAUTHORIZED.vitest-reside-123'] as any);\r\n            checkRootPollution();\r\n            expect(violations.length).toBe(1);\r\n            expect(violations[0].file).toBe('UNAUTHORIZED.vitest-reside-123');\r\n            \r\n            clearViolations();\r\n            vi.mocked(fs.readdirSync).mockReturnValue(['vitest-reside-123.SUFFIX_UNAUTHORIZED'] as any);\r\n            checkRootPollution();\r\n            expect(violations.length).toBe(1);\r\n        });\r\n\r\n        it('should kill the ALLOWED_ROOT_FILES mutants', () => {\r\n            // Check if every expected file is indeed allowed\r\n            const testFiles = ['package-lock.json', 'stryker.silver.config.mjs', 'vitest.harness.config.ts', 'tsconfig.json'];\r\n            testFiles.forEach(f => {\r\n                vi.mocked(fs.readdirSync).mockImplementation((dir, options) => {\r\n                    if (dir === ROOT_DIR) return [{ name: f, isDirectory: () => false }] as any;\r\n                    return [];\r\n                });\r\n                checkRootPollution();\r\n                expect(violations, `File ${f} should be allowed`).toHaveLength(0);\r\n                clearViolations();\r\n            });\r\n        });\r\n\r\n        it('should kill isStrict logic mutants', () => {\r\n            // Test 2_areas is considered isStrict\r\n            const areaFile = path.join(BRONZE_DIR, '2_areas', 'artifact.ts');\r\n            auditContent(areaFile, 'console.log(\"no-permitted\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });\r\n        \r\n        it('should handle Semgrep missing venv (Killing Semgrep survivors)', () => {\r\n            vi.mocked(fs.existsSync).mockImplementation(p => !String(p).includes('.venv')); \r\n            const spy = vi.spyOn(console, 'warn').mockImplementation(() => {});\r\n            \r\n            runSemgrepAudit();\r\n            \r\n            expect(spy).toHaveBeenCalledWith(expect.stringContaining('Red Queen blindfolded'));\r\n            spy.mockRestore();\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Terminal & Environment (Killing Survivours)', () => {\r\n        let consoleSpy: any;\r\n\r\n        beforeEach(() => {\r\n            consoleSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\r\n        });\r\n\r\n        afterEach(() => {\r\n            consoleSpy.mockRestore();\r\n        });\r\n\r\n        it('should format console output correctly when not in test mode', () => {\r\n            // Force non-test mode behavior manually for coverage\r\n            process.env.HFO_TEST_MODE = 'false';\r\n            \r\n            scream({ file: 'test.ts', type: 'POLLUTION' as any, message: 'Bad file' });\r\n            \r\n            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('🔴 RED REGNANT SCREAM'));\r\n            \r\n            process.env.HFO_TEST_MODE = 'true';\r\n        });\r\n\r\n        it('should NOT format console output when in test mode', () => {\r\n            process.env.HFO_TEST_MODE = 'true';\r\n            scream({ file: 'test.ts', type: 'POLLUTION' as any, message: 'Bad file' });\r\n            expect(consoleSpy).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should handle non-string file objects in scream', () => {\r\n             scream({ file: { name: 'obj-file.ts' } as any, type: 'AMNESIA', message: 'test' });\r\n             expect(violations.some(v => v.file === 'obj-file.ts')).toBe(true);\r\n             \r\n             scream({ file: null as any, type: 'AMNESIA', message: 'test' });\r\n             expect(violations.some(v => v.file === 'UNKNOWN')).toBe(true);\r\n        });\r\n\r\n        it('should return quickly if root directory is missing', () => {\r\n            vi.mocked(fs.existsSync).mockImplementation(p => !String(p).includes('hfo_gen88'));\r\n            checkRootPollution();\r\n            // Should not throw and should not call readdir\r\n            expect(fs.readdirSync).not.toHaveBeenCalled();\r\n        });\r\n\r\n        it('should kill mutants in ALLOWED_ROOT_FILES list by process of exclusion', () => {\r\n             // We verify that every official allowed file is actually allowed\r\n             const hardcodedAllowed = [\r\n                'AGENTS.md', 'llms.txt',\r\n                'obsidianblackboard.jsonl', 'package.json', 'package-lock.json',\r\n                'stryker.root.config.mjs', 'vitest.root.config.ts',\r\n                '.gitignore', '.env', 'tsconfig.json'\r\n             ];\r\n             \r\n             for (const file of hardcodedAllowed) {\r\n                 vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt(file, false)] as any);\r\n                 clearViolations();\r\n                 checkRootPollution();\r\n                 expect(violations).toHaveLength(0);\r\n             }\r\n\r\n             // Folders handled by exclusion list\r\n             const folders = ['hot_obsidian_sandbox', 'cold_obsidian_sandbox', '.git', '.github', '.vscode', '.husky', '.venv', 'node_modules'];\r\n             for (const folder of folders) {\r\n                 vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt(folder, true)] as any);\r\n                 clearViolations();\r\n                 checkRootPollution();\r\n                 expect(violations).toHaveLength(0);\r\n             }\r\n        });\r\n\r\n        it('should kill mutants in ALLOWED_ROOT_PATTERNS list', () => {\r\n            const matches = ['vitest.custom.ts', 'vitest.root.config.ts'];\r\n            for (const file of matches) {\r\n                vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt(file, false)] as any);\r\n                clearViolations();\r\n                checkRootPollution();\r\n                expect(violations).toHaveLength(0);\r\n            }\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Surgical Mutant Kills (Gen 88 Pareto)', () => {\r\n        it('should kill mutants in content.includes chains by exhaustive checking', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            // Test https\r\n            auditContent(strict, 'const x = \"https://cdn.com/lib.js\";\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n            clearViolations();\r\n            \r\n            // Test http\r\n            auditContent(strict, 'const x = \"http://cdn.com/lib.js\";\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n            clearViolations();\r\n            \r\n            // Test both with @permitted\r\n            auditContent(strict, 'const x = \"http://cdn.com/lib.js\"; // @permitted\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'PHANTOM')).toBe(false);\r\n        });\r\n\r\n        it('should kill mutants in scanMedallions iteration logic', () => {\r\n             const mockGold = path.join(HOT_DIR, 'gold');\r\n             vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                 const sp = String(p).replace(/\\\\/g, '/');\r\n                 if (sp.endsWith('/gold')) return [{ name: 'truth.js', isDirectory: () => false }] as any;\r\n                 return [];\r\n             });\r\n             vi.mocked(fs.existsSync).mockReturnValue(true);\r\n             vi.mocked(fs.readFileSync).mockReturnValue('// TODO: technical debt');\r\n             \r\n             scanMedallions();\r\n             // Should detect AMNESIA in gold/truth.js\r\n             expect(violations.some(v => v.type === 'AMNESIA' && v.file.includes('truth.js'))).toBe(true);\r\n        });\r\n\r\n        it('should kill mutants in isStrict logic for P5 exceptions', () => {\r\n             const p5file = path.join(HOT_DIR, 'silver', 'P5_PYRE_PRAETORIAN', 'logic.ts');\r\n             auditContent(p5file, 'console.log(\"no-permitted\");\\nProvenance: test');\r\n             // Should NOT trigger AMNESIA because it's in P5 path (allowance for audit engine self-logs)\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(false);\r\n             \r\n             const otherfile = path.join(HOT_DIR, 'silver', 'OTHER', 'logic.ts');\r\n             auditContent(otherfile, 'console.log(\"no-permitted\");\\nProvenance: test');\r\n             // SHOULD trigger AMNESIA\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });\r\n\r\n        it('should kill mutants in checkMutationProof score calculation', () => {\r\n             // Test total === 0 skip\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 files: { 'core.ts': { mutants: [] } }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations).toHaveLength(0);\r\n\r\n             // Test mutants.length === 0 skip\r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 files: { 'core.ts': { mutants: [] } }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations).toHaveLength(0);\r\n        });\r\n\r\n        it('should kill mutants that weaken regex patterns in scanMedallions', () => {\r\n             const mockSilver = path.join(HOT_DIR, 'silver');\r\n             // Test file ending in .ts.bak (should NOT match \\.ts$)\r\n             vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                 const sp = String(p).replace(/\\\\/g, '/');\r\n                 if (sp.endsWith('/silver')) return [{ name: 'logic.ts.bak', isDirectory: () => false }] as any;\r\n                 return [];\r\n             });\r\n             vi.mocked(fs.existsSync).mockReturnValue(true);\r\n             scanMedallions();\r\n             expect(violations.some(v => v.message.includes('missing test'))).toBe(false);\r\n        });\r\n\r\n        it('should kill individual logical operator mutants in phantom check', () => {\r\n             // Test indexing into content.includes results\r\n             auditContent('test.html', 'https://cdn.com/');\r\n             expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n             clearViolations();\r\n             \r\n             auditContent('test.html', 'http://cdn.com/');\r\n             expect(violations.some(v => v.type === 'PHANTOM')).toBe(true);\r\n             clearViolations();\r\n             \r\n             // Test !hasPermitted\r\n             auditContent('test.html', 'https://cdn.com/ // @permitted');\r\n             expect(violations.some(v => v.type === 'PHANTOM')).toBe(false);\r\n        });\r\n\r\n        it('should kill survivors in scream and console formatting', () => {\r\n             const originalLog = console.log;\r\n             const originalError = console.error;\r\n             const logSpy = vi.fn();\r\n             const errorSpy = vi.fn();\r\n             console.log = logSpy;\r\n             console.error = errorSpy;\r\n             \r\n             try {\r\n                 // Force NOT in test mode temporarily to hit console.error branch\r\n                 const oldTestMode = process.env.HFO_TEST_MODE;\r\n                 delete process.env.HFO_TEST_MODE;\r\n                 \r\n                 scream({ file: 'test.ts', type: 'DEBT', message: 'test logic' });\r\n                 expect(errorSpy).toHaveBeenCalled();\r\n                 \r\n                 process.env.HFO_TEST_MODE = oldTestMode;\r\n             } finally {\r\n                 console.log = originalLog;\r\n                 console.error = originalError;\r\n             }\r\n        });\r\n\r\n        it('should kill mutants in Galois Lattice constants', () => {\r\n             // We can't easily kill these because they are constants, \r\n             // but we can ensure they are used exactly in the logic.\r\n             expect(LATTICE.O4).toBe(4096);\r\n             expect(LATTICE.GEN).toBe(88);\r\n        });\r\n\r\n        it('should kill mutants in ALLOWED_ROOT_FILES by exhaustive check', () => {\r\n             ALLOWED_ROOT_FILES.forEach(file => {\r\n                 vi.mocked(fs.readdirSync).mockReturnValue([{ name: file, isDirectory: () => false }] as any);\r\n                 checkRootPollution();\r\n                 expect(violations).toHaveLength(0);\r\n                 clearViolations();\r\n             });\r\n        });\r\n\r\n        it('should kill mutants in checkMutationProof score comparisons', () => {\r\n             // Score >= 99 should trigger THEATER\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 99.00 } }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n             clearViolations();\r\n\r\n             // Score 98.88 should NOT trigger THEATER\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 98.88 } }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n             clearViolations();\r\n\r\n             // Score 88.00 should NOT trigger FAILURE\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 88.00 } }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n             clearViolations();\r\n\r\n             // Score 87.99 should trigger FAILURE\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 87.99 } }));\r\n             checkMutationProof(88);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n        });\r\n\r\n        it('should handle Timeout as Killed in score calculation', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 files: { 'core.ts': { mutants: [{ status: 'Killed' }, { status: 'Timeout' }, { status: 'Survived' }] } }\r\n             }));\r\n             checkMutationProof(88);\r\n             // 2/3 = 66.67% < 88%\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n             expect(violations.find(v => v.file === 'core.ts')?.message).toContain('66.67%');\r\n        });\r\n\r\n        it('should kill mutants in auditContent multi-condition checks', () => {\r\n             const silver = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n             \r\n             // No provenance AND no validates\r\n             auditContent(silver, 'const x = 1;');\r\n             expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(true);\r\n             expect(violations.some(v => v.type === 'VIOLATION')).toBe(false); // Wait, RED_REGNANT doesn't have VIOLATION type for missing provenance?\r\n             // Checking RED_REGNANT.ts... It uses BDD_MISALIGNMENT for both.\r\n             \r\n             clearViolations();\r\n             // Has provenance\r\n             auditContent(silver, '@provenance test');\r\n             expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(false);\r\n             \r\n             clearViolations();\r\n             // Has validates\r\n             auditContent(silver, 'Validates: REQ1');\r\n             expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(false);\r\n        });\r\n\r\n        it('should kill scanMedallions iteration logic mutants', () => {\r\n             vi.mocked(fs.existsSync).mockImplementation((p) => {\r\n                 const sp = String(p).replace(/\\\\/g, '/');\r\n                 if (sp.endsWith('.test.ts') || sp.endsWith('.property.ts')) return false;\r\n                 return true;\r\n             });\r\n             vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                 const sp = String(p).replace(/\\\\/g, '/');\r\n                 if (sp.endsWith('/silver')) return [{ name: 'logic.ts', isDirectory: () => false }] as any;\r\n                 return [];\r\n             });\r\n             \r\n             scanMedallions();\r\n             expect(violations.some(v => v.type === 'THEATER' && v.message.includes('Strict artifact missing test file'))).toBe(true);\r\n        });\r\n\r\n        it('should kill mutation score math mutants', () => {\r\n             // Test total === 0 branch exactly\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 files: { 'empty.ts': { mutants: [] } }\r\n             }));\r\n             checkMutationProof(80.00);\r\n             expect(violations).toHaveLength(0);\r\n\r\n             // Test killed calculation (Killed OR Timeout)\r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 files: { 'calc.ts': { mutants: [{ status: 'Killed' }, { status: 'Timeout' }, { status: 'Survived' }] } }\r\n             }));\r\n             checkMutationProof(60.00); \r\n             // 2/3 = 66.67% >= 60.00%. Should PASS.\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n             \r\n             clearViolations();\r\n             checkMutationProof(70.00);\r\n             // 66.67% < 70.00%. Should FAIL.\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE' && v.file === 'calc.ts')).toBe(true);\r\n        });\r\n\r\n        it('should kill mutation threshold boundary exactly', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 80.00 } }));\r\n             checkMutationProof(80.00); \r\n             // Mutants change < 80.00 to <= 80.00. \r\n             // 80.00 < 80.00 is FALSE. 80.00 <= 80.00 is TRUE.\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n             \r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 79.99 } }));\r\n             checkMutationProof(80.00);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n        });\r\n\r\n        it('should persist violations to DuckDB (Kraken Store)', async () => {\r\n             const sampleViolations = [\r\n                 { file: 'test.ts', type: 'POLLUTION' as any, message: 'bad' }\r\n             ];\r\n             const result = await persistToKraken(sampleViolations);\r\n             expect(result).toBe(true);\r\n        });\r\n\r\n        it('should handle empty violations list in Kraken store', async () => {\r\n             const result = await persistToKraken([]);\r\n             expect(result).toBe(true);\r\n        });\r\n\r\n        describe('Final Surgical Kills (Gen 88 Pareto)', () => {\r\n            it('should kill isBronze toUpperCase mutant', () => {\r\n                clearViolations();\r\n                // If it was toUpperCase().includes('bronze'), this would fail\r\n                auditContent('c:/Dev/bronze/logic.ts', 'console.log(\"debug\");');\r\n                expect(violations.find(v => v.type === 'AMNESIA')).toBeUndefined();\r\n            });\r\n\r\n            it('should kill TODO/FIXME string literal mutants', () => {\r\n                clearViolations();\r\n                auditContent('logic.ts', 'TO' + 'DO');\r\n                expect(violations.find(v => v.type === 'AMNESIA')).toBeDefined();\r\n                \r\n                clearViolations();\r\n                auditContent('logic.ts', 'FIX' + 'ME');\r\n                expect(violations.find(v => v.type === 'AMNESIA')).toBeDefined();\r\n\r\n                clearViolations();\r\n                // If 'TO' was replaced by \"\"\r\n                auditContent('logic.ts', 'DO'); \r\n                expect(violations.find(v => v.type === 'AMNESIA' && v.message.includes('AI SLOP'))).toBeUndefined();\r\n            });\r\n\r\n            it('should kill scanMedallions directory exclusion mutants', () => {\r\n                const mockEntries = [\r\n                    { name: '.git', isDirectory: () => true, isFile: () => false },\r\n                    { name: 'node_modules', isDirectory: () => true, isFile: () => false },\r\n                    { name: 'quarantine', isDirectory: () => true, isFile: () => false },\r\n                    { name: '.venv', isDirectory: () => true, isFile: () => false }\r\n                ];\r\n                vi.spyOn(fs, 'readdirSync').mockReturnValue(mockEntries as any);\r\n                scanMedallions();\r\n                // Should not recurse into these or audit them\r\n                expect(violations).toHaveLength(0);\r\n            });\r\n\r\n            it('should kill scream file parameter normalization mutants', () => {\r\n                clearViolations();\r\n                scream({ file: { name: 'custom.ts' }, type: 'VIOLATION', message: 'msg' });\r\n                expect(violations[0].file).toBe('custom.ts');\r\n\r\n                clearViolations();\r\n                scream({ file: null as any, type: 'VIOLATION', message: 'msg' });\r\n                expect(violations[0].file).toBe('UNKNOWN');\r\n                \r\n                clearViolations();\r\n                scream({ file: { toString: () => 'toString-file' }, type: 'VIOLATION', message: 'msg' });\r\n                expect(violations[0].file).toBe('toString-file');\r\n            });\r\n\r\n            it('should kill mutation score comparison boundary (Killing < vs <=)', () => {\r\n                clearViolations();\r\n                vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 88.00 } }));\r\n                checkMutationProof(88.00); \r\n                // score < threshold (88 < 88) is false -> NO violation.\r\n                // If mutant changes to score <= threshold (88 <= 88) is true -> violation.\r\n                expect(violations.find(v => v.type === 'MUTATION_FAILURE')).toBeUndefined();\r\n            });\r\n\r\n            it('should kill isStrict zone detection mutants', () => {\r\n                clearViolations();\r\n                auditContent('silver/logic.ts', 'console.log(\"debug\")');\r\n                expect(violations.find(v => v.type === 'AMNESIA')).toBeDefined();\r\n\r\n                clearViolations();\r\n                auditContent('2_areas/logic.ts', 'console.log(\"debug\")');\r\n                expect(violations.find(v => v.type === 'AMNESIA')).toBeDefined();\r\n            });\r\n\r\n            it('should hit Semgrep audit and parse issues', () => {\r\n                vi.spyOn(fs, 'existsSync').mockImplementation((p: string) => p.includes('semgrep.exe') || p.includes('silver'));\r\n                vi.spyOn(fs, 'readdirSync').mockReturnValue(['logic.ts'] as any);\r\n                const mockSemgrepOutput = JSON.stringify({\r\n                    results: [\r\n                        { path: 'silver/logic.ts', start: { line: 10 }, extra: { message: 'Theater detected' } }\r\n                    ]\r\n                });\r\n                vi.mocked(child_process.execSync).mockReturnValue(mockSemgrepOutput as any);\r\n                \r\n                runSemgrepAudit();\r\n                expect(violations.find(v => v.type === 'THEATER' && v.message.includes('Theater detected'))).toBeDefined();\r\n            });\r\n\r\n            it('should handle Semgrep errors with stdout payload', () => {\r\n                vi.spyOn(fs, 'existsSync').mockReturnValue(true);\r\n                const error: any = new Error('Semgrep failed');\r\n                error.stdout = JSON.stringify({\r\n                    results: [{ path: 'silver/err.ts', start: { line: 5 }, extra: { message: 'Semantic Error' } }]\r\n                });\r\n                vi.mocked(child_process.execSync).mockImplementation(() => { throw error; });\r\n                \r\n                runSemgrepAudit();\r\n                expect(violations.find(v => v.message.includes('Semantic Error'))).toBeDefined();\r\n            });\r\n\r\n            it('should audit Silver Shroud with Zod logic', () => {\r\n                vi.spyOn(fs, 'existsSync').mockReturnValue(true);\r\n                vi.spyOn(fs, 'readdirSync').mockReturnValue(['P0_SERVICE.ts'] as any);\r\n                vi.spyOn(fs, 'readFileSync').mockReturnValue('@port 0\\n@commander Lidless\\n@gen 88\\n@status SILVER\\n@provenance requirement\\n// content');\r\n                \r\n                checkSilverShroud();\r\n                // Should pass validation\r\n                if (violations.length > 0) {\r\n                    console.error('Violations found in Silver Shroud test:', JSON.stringify(violations, null, 2));\r\n                }\r\n                expect(violations).toHaveLength(0);\r\n\r\n                clearViolations();\r\n                vi.spyOn(fs, 'readFileSync').mockReturnValue('// No headers');\r\n                checkSilverShroud();\r\n                // Should fail validation (since port/commander are undefined and ArtifactContract doesn't default them)\r\n                expect(violations.find(v => v.type === 'VIOLATION')).toBeDefined();\r\n            });\r\n\r\n            it('should analyze suspicion via empty catch blocks', () => {\r\n                clearViolations();\r\n                analyzeSuspicion('logic.ts', 'try { f(); } catch(e) {}');\r\n                expect(violations.find(v => v.type === 'OMISSION')).toBeDefined();\r\n            });\r\n\r\n            it('should analyze suspicion via ignore markers', () => {\r\n                clearViolations();\r\n                analyzeSuspicion('logic.ts', '// @ignore-regnant');\r\n                expect(violations.find(v => v.type === 'SUSPICION' && v.message.includes('ignore-regnant'))).toBeDefined();\r\n            });\r\n\r\n            it('should detect AI theater overloads (Port 4 Surgical Kill)', () => {\r\n                const multiMock = 'vi.mock(\"a\"); vi.mock(\"b\"); vi.mock(\"c\"); vi.mock(\"d\"); vi.mock(\"e\"); vi.mock(\"f\");';\r\n                auditContent('test.test.ts', multiMock);\r\n                expect(violations.find(v => v.type === 'THEATER' && v.message.includes('Theater Overload'))).toBeDefined();\r\n            });\r\n\r\n            it('should detect mocks in non-test strict files', () => {\r\n                const silverFile = path.join(HOT_DIR, 'silver/logic.ts');\r\n                auditContent(silverFile, 'vi.mock(\"deps\")');\r\n                expect(violations.find(v => v.type === 'THEATER' && v.message.includes('Logic bypass detected'))).toBeDefined();\r\n            });\r\n\r\n            it('should kill regex mutants in placeholder detection', () => {\r\n                clearViolations();\r\n                analyzeSuspicion('logic.ts', 'throw new Error(\"Not implemented\")');\r\n                expect(violations.find(v => v.type === 'THEATER')).toBeDefined();\r\n                \r\n                clearViolations();\r\n                analyzeSuspicion('logic.ts', '// Logic goes here');\r\n                expect(violations.find(v => v.type === 'THEATER')).toBeDefined();\r\n            });\r\n        });\r\n    });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P5_PYRE_PRAETORIAN/PYRE_PRAETORIAN.test.ts":{"tests":[{"id":"95","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Environment & Scream Protocol (Killing Core mutants) should have non-negotiable environments"},{"id":"96","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Environment & Scream Protocol (Killing Core mutants) should handle non-string files in scream (Killing Ternary mutants)"},{"id":"97","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Environment & Scream Protocol (Killing Core mutants) should clear violations completely (Killing Array mutants)"},{"id":"98","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should allow debug logs with @permitted"},{"id":"99","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should allow any with @bespoke"},{"id":"100","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should handle mutation report parse failures"},{"id":"101","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should handle missing mutation report"},{"id":"102","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect TODO and FIXME"},{"id":"103","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect console.debug in strict zones"},{"id":"104","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect PHANTOM dependencies in index.html"},{"id":"105","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Additional Coverage (Pushing score to 80%+) should detect BDD_MISALIGNMENT in strict zones"},{"id":"106","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should match violation messages exactly"},{"id":"107","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should verify mutation score boundary conditions"},{"id":"108","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should handle non-number mutation score"},{"id":"109","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect unauthorized debug logs correctly"},{"id":"110","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect bespoke any correctly"},{"id":"111","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should detect violations in special zones"},{"id":"112","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Strict Coverage (Killing Exact String Mutants) should kill mutants in ALLOWED_ROOT_FILES list by exhaustive check"},{"id":"113","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate Manifest and block invalid DNA"},{"id":"114","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate Playbook format (Killing literal mutants)"},{"id":"115","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Schemas & Data Integrity (Killing Zod mutants) should validate BloodBook entry"},{"id":"116","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should detect unauthorized files"},{"id":"117","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should kill mutants that weaken regex patterns"},{"id":"118","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should strictly enforce boundaries for all regex patterns (Mutant Kills)"},{"id":"119","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Root Pollution (Killing Regex & List mutants) should handle the logical OR between list and patterns"},{"id":"120","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should detect technical debt and strict zone violations"},{"id":"121","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should detect assertionless tests"},{"id":"122","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Content Auditing (Killing Audit mutants) should allow tests with either expect or assert"},{"id":"123","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should detect WEAK_EVOLUTION (Killing NoCoverage & boundaries)"},{"id":"124","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should detect THEATER (Killing String/Math/Boundary mutants)"},{"id":"125","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should handle Timeout as Killed"},{"id":"126","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Mutation Proof Auditing (Killing Mutation Logic mutants) should handle mutation report with files having empty mutants array (Killing foundAny mutants)"},{"id":"127","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Medallion Scanning (Killing Loop & skip mutants) should recurse subdirectories and detect missing tests"},{"id":"128","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Lockdown Execution should return violations for enforcement (H-I behavior)"},{"id":"129","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Lockdown Execution should return success if no violations exist"},{"id":"130","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should strictly enforce regex boundaries in root patterns"},{"id":"131","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should identify strict zones with surgical precision (Killing isStrictZone mutants)"},{"id":"132","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should kill negation mutants in isPermitted/isBespoke"},{"id":"133","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should handle malformed mutation report metrics correctly"},{"id":"134","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should kill survivors in scream and console formatting"},{"id":"135","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should kill mutants in ALLOWED_ROOT_FILES by exhaustive check"},{"id":"136","name":"Pyre Praetorian: Immunological Defense (Lockdown Suite) Quine Commander: Surgical Mutant Kills (P5 Expansion) should kill mutants in checkMutationProof score comparisons"}],"source":"import { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport * as fs from 'node:fs';\r\nimport * as path from 'node:path';\r\n\r\n// Set test mode before importing the module\r\nprocess.env.HFO_TEST_MODE = 'true';\r\n\r\nimport { \r\n    checkRootPollution, \r\n    checkMutationProof, \r\n    auditContent,\r\n    scanMedallions,\r\n    executePyreAudit,\r\n    violations,\r\n    clearViolations,\r\n    scream,\r\n    ALLOWED_ROOT_FILES,\r\n    ALLOWED_ROOT_PATTERNS,\r\n    ROOT_DIR,\r\n    BRONZE_DIR,\r\n    HOT_DIR,\r\n    IS_TEST_MODE,\r\n    CacaoPlaybookSchema,\r\n    BloodBookEntrySchema,\r\n    ManifestSchema\r\n} from './PYRE_PRAETORIAN.js';\r\n\r\nvi.mock('node:fs');\r\n\r\ndescribe('Pyre Praetorian: Immunological Defense (Lockdown Suite)', () => {\r\n    beforeEach(() => {\r\n        vi.clearAllMocks();\r\n        clearViolations();\r\n        vi.mocked(fs.existsSync).mockReturnValue(true);\r\n    });\r\n\r\n    describe('Environment & Scream Protocol (Killing Core mutants)', () => {\r\n        it('should have non-negotiable environments', () => {\r\n            expect(IS_TEST_MODE).toBe(true);\r\n            expect(typeof ROOT_DIR).toBe('string');\r\n        });\r\n\r\n        it('should handle non-string files in scream (Killing Ternary mutants)', () => {\r\n            scream({ file: { name: 'object-file' } as any, type: 'THEATER', message: 'test' });\r\n            expect(violations[0].file).toBe('object-file');\r\n            \r\n            clearViolations();\r\n            scream({ file: 123 as any, type: 'THEATER', message: 'test' });\r\n            expect(violations[0].file).toBe('123');\r\n            \r\n            clearViolations();\r\n            scream({ file: null as any, type: 'THEATER', message: 'test' });\r\n            expect(violations[0].file).toBe('UNKNOWN');\r\n        });\r\n\r\n        it('should clear violations completely (Killing Array mutants)', () => {\r\n            scream({ file: 'test.ts', type: 'DEBT', message: 'test' });\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n            expect(violations).toHaveLength(0);\r\n            expect(Array.isArray(violations)).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Additional Coverage (Pushing score to 80%+)', () => {\r\n        it('should allow debug logs with @permitted', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'console.log(\"test\"); // @permitted\\nProvenance: test');\r\n            expect(violations.find(v => v.type === 'AMNESIA')).toBeUndefined();\r\n        });\r\n\r\n        it('should allow any with @bespoke', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'const x: any = 1; // @bespoke\\nProvenance: test');\r\n            expect(violations.find(v => v.type === 'BESPOKE')).toBeUndefined();\r\n        });\r\n\r\n        it('should handle mutation report parse failures', () => {\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue('invalid json');\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n        });\r\n\r\n        it('should handle missing mutation report', () => {\r\n            const reportPath = path.join(BRONZE_DIR, 'infra/reports/mutation/mutation.json');\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => p !== reportPath);\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n        });\r\n        \r\n        it('should detect TODO and FIXME', () => {\r\n            auditContent('file.ts', '// TODO items');\r\n            expect(violations.some(v => v.type === 'DEBT' && v.message.includes('TODO/FIXME'))).toBe(true);\r\n            clearViolations();\r\n            auditContent('file.ts', '// FIXME items');\r\n            expect(violations.some(v => v.type === 'DEBT' && v.message.includes('TODO/FIXME'))).toBe(true);\r\n        });\r\n\r\n        it('should detect console.debug in strict zones', () => {\r\n            const strict = path.join(HOT_DIR, 'gold', 'logic.ts');\r\n            auditContent(strict, 'console.debug(\"test\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });\r\n\r\n        it('should detect PHANTOM dependencies in index.html', () => {\r\n            auditContent('index.html', '<script src=\"https://cdn.com/lib.js\"></script>');\r\n            expect(violations.find(v => v.type === 'PHANTOM')?.message).toBe('External CDN dependency detected.');\r\n            clearViolations();\r\n            auditContent('script.ts', 'fetch(\"http://cdn.com/api\")');\r\n            expect(violations.find(v => v.type === 'PHANTOM')).toBeDefined();\r\n        });\r\n\r\n        it('should detect BDD_MISALIGNMENT in strict zones', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            // Missing Validates or @provenance\r\n            auditContent(strict, 'Provenance: test\\nconst x = 1;');\r\n            expect(violations.find(v => v.type === 'BDD_MISALIGNMENT')?.message).toBe('Implementation file missing requirement traceability (Validates: or @provenance).');\r\n            \r\n            clearViolations();\r\n            // Has Validates\r\n            auditContent(strict, 'Provenance: test\\n// Validates: Req1');\r\n            expect(violations.some(v => v.type === 'BDD_MISALIGNMENT')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('Strict Coverage (Killing Exact String Mutants)', () => {\r\n        it('should match violation messages exactly', () => {\r\n            auditContent('file.ts', '// TODO');\r\n            expect(violations[0].message).toBe('TODO/FIXME detected.');\r\n            clearViolations();\r\n            \r\n            vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'POISON.exe', isDirectory: () => false }] as any);\r\n            checkRootPollution();\r\n            const badFile = violations.find(v => v.type === 'POLLUTION');\r\n            if (badFile) {\r\n                expect(badFile.message).toBe('Unauthorized root file detected.');\r\n            }\r\n        });\r\n\r\n        it('should verify mutation score boundary conditions', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 80 }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n\r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 79.9 }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n             \r\n             clearViolations();\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: 99 }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n        });\r\n\r\n        it('should handle non-number mutation score', () => {\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({\r\n                 metrics: { mutationScore: \"100\" }\r\n             }));\r\n             checkMutationProof(80);\r\n             expect(violations.find(v => v.message === 'Invalid score format in metrics.')).toBeDefined();\r\n        });\r\n        \r\n        it('should detect unauthorized debug logs correctly', () => {\r\n             const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n             auditContent(strict, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.find(v => v.type === 'AMNESIA')?.message).toBe('Unauthorized debug logs.');\r\n        });\r\n\r\n        it('should detect bespoke any correctly', () => {\r\n             const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n             auditContent(strict, 'let x: any;\\nProvenance: test');\r\n             expect(violations.find(v => v.type === 'BESPOKE')?.message).toBe('Bespoke \"any\" type without justification.');\r\n        });\r\n        it('should detect violations in special zones', () => {\r\n             const areaPath = path.join(HOT_DIR, '2_areas', 'logic.ts');\r\n             auditContent(areaPath, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n\r\n             clearViolations();\r\n             const goldPath = path.join(HOT_DIR, 'gold', 'logic.ts');\r\n             auditContent(goldPath, 'console.log(\"test\");\\nProvenance: test');\r\n             expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n        });        \r\n        it('should kill mutants in ALLOWED_ROOT_FILES list by exhaustive check', () => {\r\n            // We can't easily mutate the constant in the test, \r\n            // but we can ensure every entry in ALLOWED_ROOT_FILES is actually used \r\n            // if we were to mock readdir results for each.\r\n            const important = [\r\n                'package.json', 'stryker.root.config.mjs', 'vitest.root.config.ts', '.gitignore', \r\n                'reports', 'output.txt', 'LICENSE', 'hot_obsidian_sandbox', 'cold_obsidian_sandbox',\r\n                'AGENTS.md', 'llms.txt', 'obsidianblackboard.jsonl', 'package-lock.json',\r\n                'stryker.silver.config.mjs', 'vitest.silver.config.ts', 'vitest.harness.config.ts',\r\n                'vitest.mutation.config.ts', 'stryker.config.mjs', 'vitest.config.ts', '.git',\r\n                '.github', '.vscode', '.env', '.kiro', '.venv', 'tsconfig.json', '.stryker-tmp',\r\n                '.husky', 'node_modules'\r\n            ];\r\n            important.forEach(file => {\r\n                vi.mocked(fs.readdirSync).mockReturnValue([{ name: file, isDirectory: () => false }] as any);\r\n                checkRootPollution();\r\n                expect(violations, `Expected ${file} to be allowed`).toHaveLength(0);\r\n                clearViolations();\r\n            });\r\n        });\r\n    });\r\n\r\n    describe('Schemas & Data Integrity (Killing Zod mutants)', () => {\r\n        it('should validate Manifest and block invalid DNA', () => {\r\n            const valid = {\r\n                identity: { port: 4, commander: 'Red' },\r\n                galois_lattice: { coordinate: [1, 1] },\r\n                dna: { hfo_generation: 88 }\r\n            };\r\n            expect(ManifestSchema.parse(valid)).toMatchObject(valid);\r\n            expect(() => ManifestSchema.parse({ ...valid, identity: { port: '4' } as any })).toThrow();\r\n            expect(() => ManifestSchema.parse({ ...valid, galois_lattice: { coordinate: [1] } })).toThrow();\r\n        });\r\n\r\n        it('should validate Playbook format (Killing literal mutants)', () => {\r\n            const pb = { type: 'playbook', id: 'playbook--1', name: 'N', description: 'D', steps: [{ type: 'T', name: 'N', description: 'D' }] };\r\n            expect(CacaoPlaybookSchema.parse(pb)).toMatchObject(pb);\r\n            \r\n            // Negative ID check\r\n            expect(() => CacaoPlaybookSchema.parse({ ...pb, id: 'pb-1' })).toThrow();\r\n            \r\n            expect(() => CacaoPlaybookSchema.parse({ ...pb, steps: [{ name: 'N' }] as any })).toThrow();\r\n        });\r\n\r\n        it('should validate BloodBook entry', () => {\r\n            const entry = {\r\n                index: 1,\r\n                ts: '2026-01-01',\r\n                artifact_id: 'A',\r\n                resonance_signature: 'S',\r\n                prev_hash: '0',\r\n                hash: 'H'\r\n            };\r\n            expect(BloodBookEntrySchema.parse(entry)).toMatchObject(entry);\r\n            expect(() => BloodBookEntrySchema.parse({ ...entry, index: '1' } as any)).toThrow();\r\n        });\r\n    });\r\n\r\n    describe('Root Pollution (Killing Regex & List mutants)', () => {\r\n        const mockDirEnt = (name: string, isDir = false) => ({ name, isDirectory: () => isDir } as fs.Dirent);\r\n\r\n        it('should detect unauthorized files', () => {\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('POISON.exe')] as any);\r\n            checkRootPollution();\r\n            expect(violations.some(v => v.type === 'POLLUTION')).toBe(true);\r\n        });\r\n\r\n        it('should kill mutants that weaken regex patterns', () => {\r\n            // Test that startsWith and endsWith are enforced (^ and $)\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('OLD-ttao-notes-2026.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-2026.md.bak')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('PREFIX.vitest.config.ts')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-2026.txt')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(1);\r\n            clearViolations();\r\n            \r\n            // Test vitest prefix\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('vitest.logic.ts')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0); // Allowed by pattern /^vitest\\..*$/\r\n        });\r\n\r\n        it('should strictly enforce boundaries for all regex patterns (Mutant Kills)', () => {\r\n            const boundaryTests = [\r\n                { name: 'X.stryker-tmp', shouldPass: false },\r\n                { name: '.stryker-tmp-123', shouldPass: true }, // killing '.*' mutants\r\n                { name: 'X.vitest-reside-123', shouldPass: false },\r\n                { name: '.vitest-reside-123', shouldPass: true },\r\n                { name: 'pre-vitest.root.config.ts.timestamp-123', shouldPass: false },\r\n                { name: 'vitest.root.config.ts.timestamp-123', shouldPass: true },\r\n                { name: 'Xttao-notes-reboot.md', shouldPass: false },\r\n                { name: 'ttao-notes-reboot.md.txt', shouldPass: false }\r\n            ];\r\n\r\n            boundaryTests.forEach(t => {\r\n                vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt(t.name)] as any);\r\n                checkRootPollution();\r\n                if (t.shouldPass) {\r\n                    expect(violations, `Expected ${t.name} to pass`).toHaveLength(0);\r\n                } else {\r\n                    expect(violations, `Expected ${t.name} to fail pollution check`).toHaveLength(1);\r\n                }\r\n                clearViolations();\r\n            });\r\n        });\r\n\r\n        it('should handle the logical OR between list and patterns', () => {\r\n            // Case 1: In list, not in patterns\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('AGENTS.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0);\r\n            clearViolations();\r\n\r\n            // Case 2: Not in list, matches pattern\r\n            vi.mocked(fs.readdirSync).mockReturnValue([mockDirEnt('ttao-notes-reboot.md')] as any);\r\n            checkRootPollution();\r\n            expect(violations).toHaveLength(0);\r\n            clearViolations();\r\n        });\r\n    });\r\n\r\n    describe('Content Auditing (Killing Audit mutants)', () => {\r\n        it('should detect technical debt and strict zone violations', () => {\r\n            auditContent('file.ts', '// TODO: fix');\r\n            expect(violations[0].type).toBe('DEBT');\r\n\r\n            clearViolations();\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            auditContent(strict, 'const x: any = 1;');\r\n            expect(violations.some(v => v.type === 'BESPOKE')).toBe(true);\r\n            expect(violations.some(v => v.type === 'VIOLATION')).toBe(true);\r\n        });\r\n\r\n        it('should detect assertionless tests', () => {\r\n            auditContent('test.test.ts', 'it(\"runs\", () => {})');\r\n            expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n        });\r\n\r\n        it('should allow tests with either expect or assert', () => {\r\n             auditContent('test.test.ts', 'it(\"t\", () => { expect(1).toBe(1); })');\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n             \r\n             clearViolations();\r\n             auditContent('test.test.ts', 'it(\"t\", () => { assert.equal(1, 1); })');\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('Mutation Proof Auditing (Killing Mutation Logic mutants)', () => {\r\n        it('should detect WEAK_EVOLUTION (Killing NoCoverage & boundaries)', () => {\r\n            // Test boundary 80.00\r\n            const report80 = { metrics: { mutationScore: 80.00 } };\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report80));\r\n            checkMutationProof(80);\r\n            expect(violations).toHaveLength(0);\r\n\r\n            // Test boundary 79.99\r\n            const report79 = { metrics: { mutationScore: 79.99 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report79));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n            \r\n            clearViolations();\r\n            const reportFiles = {\r\n                files: { 'bad.ts': { mutants: [{ status: 'Killed' }, { status: 'Survived' }] } }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(reportFiles));\r\n            checkMutationProof(80);\r\n            expect(violations[0].type).toBe('MUTATION_FAILURE');\r\n            expect(violations[0].message).toContain('50.00%');\r\n        });\r\n\r\n        it('should detect THEATER (Killing String/Math/Boundary mutants)', () => {\r\n            // Test non-number score\r\n            const reportNan = { metrics: { mutationScore: '100' } };\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(reportNan));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Exact 99.00 should trigger THEATER\r\n            const report99 = { metrics: { mutationScore: 99.00 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report99));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n\r\n            clearViolations();\r\n            // 98.99 should NOT trigger THEATER\r\n            const report98 = { metrics: { mutationScore: 98.99 } };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report98));\r\n            checkMutationProof(80);\r\n            expect(violations).toHaveLength(0);\r\n        });\r\n\r\n        it('should handle Timeout as Killed', () => {\r\n            const report = {\r\n                files: { 'ok.ts': { mutants: [{ status: 'Timeout' }] } }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report));\r\n            checkMutationProof(80);\r\n            expect(violations).toHaveLength(1); // Score 100% -> THEATER\r\n            expect(violations[0].type).toBe('THEATER');\r\n        });\r\n\r\n        it('should handle mutation report with files having empty mutants array (Killing foundAny mutants)', () => {\r\n            const report = {\r\n                files: {\r\n                    'empty.ts': { mutants: [] }\r\n                }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP' && v.message.includes('Invalid progress'))).toBe(true);\r\n            \r\n            clearViolations();\r\n            const report2 = {\r\n                files: {\r\n                    'empty.ts': { mutants: [] },\r\n                    'real.ts': { mutants: [{ status: 'Killed' }] }\r\n                }\r\n            };\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify(report2));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.type === 'MUTATION_GAP')).toBe(false);\r\n        });\r\n    });\r\n\r\n    describe('Medallion Scanning (Killing Loop & skip mutants)', () => {\r\n        const mockDirEnt = (name: string, isDir = false) => ({ name, isDirectory: () => isDir } as fs.Dirent);\r\n\r\n        it('should recurse subdirectories and detect missing tests', () => {\r\n            const mockSilver = path.join(HOT_DIR, 'silver');\r\n            const mockSub = path.join(mockSilver, 'feature');\r\n            const mockLogic = path.join(mockSub, 'logic.ts');\r\n            const mockTest = path.join(mockSub, 'logic.test.ts');\r\n\r\n            vi.mocked(fs.existsSync).mockImplementation((p) => {\r\n                const sp = String(p);\r\n                if (sp === mockSilver || sp === mockSub || sp === mockLogic) return true;\r\n                if (sp === mockTest) return false; // MISSING TEST\r\n                return false;\r\n            });\r\n\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                if (String(p) === mockSilver) return [mockDirEnt('feature', true)] as any;\r\n                if (String(p) === mockSub) return [mockDirEnt('logic.ts', false)] as any;\r\n                return [];\r\n            });\r\n\r\n            scanMedallions();\r\n            expect(violations.some(v => v.type === 'THEATER' && v.message.includes('missing test'))).toBe(true);\r\n        });\r\n    });\r\n\r\n    describe('Lockdown Execution', () => {\r\n        it('should return violations for enforcement (H-I behavior)', async () => {\r\n            vi.mocked(fs.readdirSync).mockImplementation((p) => {\r\n                if (p === ROOT_DIR) return [\r\n                    { name: 'SYSTEM', isDirectory: () => false },\r\n                    { name: 'RED_REGNANT.ts', isDirectory: () => false },\r\n                    { name: 'TARGET.ts', isDirectory: () => false }\r\n                ] as any;\r\n                return [];\r\n            });\r\n            vi.mocked(fs.existsSync).mockReturnValue(true);\r\n            vi.mocked(fs.readFileSync).mockReturnValue('{}');\r\n\r\n            const result = await executePyreAudit();\r\n            expect(result.success).toBe(false);\r\n            expect(result.violations.length).toBeGreaterThan(0);\r\n        });\r\n\r\n        it('should return success if no violations exist', async () => {\r\n             // Mock success\r\n             vi.mocked(fs.readdirSync).mockReturnValue([]);\r\n             vi.mocked(fs.existsSync).mockImplementation(p => String(p).includes('mutation.json'));\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 85 } }));\r\n             \r\n             const result = await executePyreAudit();\r\n             expect(result.success).toBe(true);\r\n             expect(result.violations).toHaveLength(0);\r\n        });\r\n    });\r\n\r\n    describe('Quine Commander: Surgical Mutant Kills (P5 Expansion)', () => {\r\n        it('should strictly enforce regex boundaries in root patterns', () => {\r\n            // /^vitest\\..*$/ mutant kill: Should not match \"my-vitest.config.ts\"\r\n            vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'my-vitest.config.ts', isDirectory: () => false }] as any);\r\n            checkRootPollution();\r\n            expect(violations.find(v => v.file === 'my-vitest.config.ts')).toBeDefined();\r\n            clearViolations();\r\n\r\n            // /\\.root\\.config\\.(ts|mjs)$/ mutant kill: Should not match \"config.ts.bak\"\r\n            vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'vitest.root.config.ts.bak', isDirectory: () => false }] as any);\r\n            checkRootPollution();\r\n            expect(violations.find(v => v.file === 'vitest.root.config.ts.bak')).toBeDefined();\r\n            clearViolations();\r\n\r\n            // /^ttao-notes-.*\\.md$/ mutant kill: Should not match \"ttao-notes.md\"\r\n            vi.mocked(fs.readdirSync).mockReturnValue([{ name: 'ttao-notes.md', isDirectory: () => false }] as any);\r\n            checkRootPollution();\r\n            expect(violations.find(v => v.file === 'ttao-notes.md')).toBeDefined();\r\n            clearViolations();\r\n        });\r\n\r\n        it('should identify strict zones with surgical precision (Killing isStrictZone mutants)', () => {\r\n            const hotSilver = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            const coldSilver = path.join(path.normalize('c:/Dev/active/hfo_gen88/cold_obsidian_sandbox'), 'silver', 'logic.ts');\r\n            const hotGold = path.join(HOT_DIR, 'gold', 'logic.ts');\r\n            const hotBronze = path.join(HOT_DIR, 'bronze', 'experimental.ts');\r\n\r\n            // Both silver and gold are strict\r\n            auditContent(hotSilver, 'console.log(\"no\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n            clearViolations();\r\n\r\n            auditContent(coldSilver, 'console.log(\"no\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n            clearViolations();\r\n\r\n            auditContent(hotGold, 'console.log(\"no\");\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Bronze IS NOT strict in P5 logic (only check Root pollution and basic debt)\r\n            auditContent(hotBronze, 'console.log(\"yes\");');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(false);\r\n        });\r\n\r\n        it('should kill negation mutants in isPermitted/isBespoke', () => {\r\n            const strict = path.join(HOT_DIR, 'silver', 'logic.ts');\r\n            \r\n            // \"console.log\" without specific permitted tag\r\n            auditContent(strict, 'console.log(\"test\"); // permitted\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(true);\r\n            clearViolations();\r\n\r\n            // \"console.log\" with exact permitted tag\r\n            auditContent(strict, 'console.log(\"test\"); // @permitted\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'AMNESIA')).toBe(false);\r\n            clearViolations();\r\n\r\n            // \"any\" with exact bespoke tag\r\n            auditContent(strict, 'const x: any = 1; // @bespoke\\nProvenance: test');\r\n            expect(violations.some(v => v.type === 'BESPOKE')).toBe(false);\r\n        });\r\n\r\n        it('should handle malformed mutation report metrics correctly', () => {\r\n            // Missing metrics property\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ other: {} }));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.message === 'Mutation report is missing metrics.')).toBe(true);\r\n            clearViolations();\r\n\r\n            // Metrics exists but mutationScore is missing\r\n            vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { totalKilled: 10 } }));\r\n            checkMutationProof(80);\r\n            expect(violations.some(v => v.message === 'Invalid score format in metrics.')).toBe(true);\r\n        });\r\n\r\n        it('should kill survivors in scream and console formatting', () => {\r\n             const originalLog = console.log;\r\n             const originalError = console.error;\r\n             const logSpy = vi.fn();\r\n             const errorSpy = vi.fn();\r\n             console.log = logSpy;\r\n             console.error = errorSpy;\r\n             \r\n             try {\r\n                // We can't delete IS_TEST_MODE because it's a const in the module, \r\n                // but we can test the 'else' branch by mocking it if we refactor,\r\n                // however we can at least test that scream pushes correctly.\r\n                scream({ file: 'test.ts', type: 'DEBT', message: 'test logic' });\r\n                expect(violations[violations.length - 1].file).toBe('test.ts');\r\n             } finally {\r\n                 console.log = originalLog;\r\n                 console.error = originalError;\r\n             }\r\n        });\r\n\r\n        it('should kill mutants in ALLOWED_ROOT_FILES by exhaustive check', () => {\r\n             ALLOWED_ROOT_FILES.forEach(file => {\r\n                 vi.mocked(fs.readdirSync).mockReturnValue([{ name: file, isDirectory: () => false }] as any);\r\n                 checkRootPollution();\r\n                 expect(violations).toHaveLength(0);\r\n                 clearViolations();\r\n             });\r\n        });\r\n\r\n        it('should kill mutants in checkMutationProof score comparisons', () => {\r\n             // Score >= 99 should trigger THEATER\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 99.00 } }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(true);\r\n             clearViolations();\r\n\r\n             // Score 98.99 should NOT trigger THEATER\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 98.99 } }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'THEATER')).toBe(false);\r\n             clearViolations();\r\n\r\n             // Score 80.00 should NOT trigger FAILURE\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 80.00 } }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(false);\r\n             clearViolations();\r\n\r\n             // Score 79.99 should trigger FAILURE\r\n             vi.mocked(fs.readFileSync).mockReturnValue(JSON.stringify({ metrics: { mutationScore: 79.99 } }));\r\n             checkMutationProof(80);\r\n             expect(violations.some(v => v.type === 'MUTATION_FAILURE')).toBe(true);\r\n        });\r\n    });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/contracts/obsidian-stigmergy.test.ts":{"tests":[{"id":"137","name":"OBSIDIAN Stigmergy Format - Property Tests Property 1: Port-Verb Consistency (OBSIDIAN Mapping) port and verb must be consistent for all generated events"},{"id":"138","name":"OBSIDIAN Stigmergy Format - Property Tests Property 1: Port-Verb Consistency (OBSIDIAN Mapping) should reject events with mismatched port-verb"},{"id":"139","name":"OBSIDIAN Stigmergy Format - Property Tests Property 2: Port-Phase Consistency (HIVE Mapping) port and phase must be consistent for all generated events"},{"id":"140","name":"OBSIDIAN Stigmergy Format - Property Tests Property 3: Type-Verb Consistency event type verb must match obsidianverb"},{"id":"141","name":"OBSIDIAN Stigmergy Format - Property Tests Property 4: Source-Port Consistency source URI port must match obsidianport"},{"id":"142","name":"OBSIDIAN Stigmergy Format - Property Tests Property 5: Hive-Gen Consistency hive generation must match obsidiangen"},{"id":"143","name":"OBSIDIAN Stigmergy Format - Property Tests Property 6: Round-Trip Serialization toJsonl then fromJsonl produces equivalent event"},{"id":"144","name":"OBSIDIAN Stigmergy Format - Property Tests Property 7: Schema Validation Completeness factory-created events always pass schema validation"},{"id":"145","name":"OBSIDIAN Stigmergy Format - Property Tests Property 8: Traceparent Format traceparent follows W3C format"},{"id":"146","name":"OBSIDIAN Stigmergy Format - Property Tests Boundary: Invalid Formats should reject invalid source format"},{"id":"147","name":"OBSIDIAN Stigmergy Format - Property Tests Boundary: Invalid Formats should reject invalid type format"},{"id":"148","name":"OBSIDIAN Stigmergy Format - Property Tests Boundary: Invalid Formats should reject invalid hive format"},{"id":"149","name":"OBSIDIAN Stigmergy Format - Property Tests Property 9: Traceparent Character Distribution generates IDs with varying characters (kills math mutants)"},{"id":"150","name":"OBSIDIAN Stigmergy Format - Property Tests Integration: File Parsing should parse multiple events from JSONL string"},{"id":"151","name":"OBSIDIAN Stigmergy Format - Property Tests Integration: File Parsing should ignore empty lines in JSONL"},{"id":"152","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 1: Invalid Port Values should reject port values outside 0-7"},{"id":"153","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 2: Invalid Verb Values should reject verbs not in OBSIDIAN set"},{"id":"154","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 3: Mismatched Port-Verb should reject events where port does not match verb"},{"id":"155","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 4: Mismatched Port-Phase should reject events where port does not match phase"},{"id":"156","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 5: Invalid Traceparent Format should reject malformed traceparent"},{"id":"157","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 6: Invalid Source URI should reject malformed source URIs"},{"id":"158","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 7: Invalid Event Type Format should reject malformed event types"},{"id":"159","name":"OBSIDIAN Stigmergy Format - Mutation Tests Mutation 8: Mismatched Hive-Gen should reject events where hive does not match gen"},{"id":"160","name":"OBSIDIAN Stigmergy Format - Edge Cases should handle empty data payload"},{"id":"161","name":"OBSIDIAN Stigmergy Format - Edge Cases should handle complex nested data payload"},{"id":"162","name":"OBSIDIAN Stigmergy Format - Edge Cases should handle all 8 ports correctly"},{"id":"163","name":"OBSIDIAN Stigmergy Format - Edge Cases should handle all 3 layers correctly"},{"id":"164","name":"OBSIDIAN Stigmergy Format - Edge Cases should handle BDD fields (given/when/then)"}],"source":"/**\r\n * OBSIDIAN Stigmergy Format - Property Tests\r\n * \r\n * Tests the Gen 88 stigmergy format for correctness properties.\r\n * Uses fast-check for property-based testing.\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport * as fc from 'fast-check';\r\nimport {\r\n  ObsidianStigmergySchema,\r\n  ObsidianStigmergy,\r\n  ObsidianPort,\r\n  ObsidianVerb,\r\n  ObsidianPhase,\r\n  ObsidianLayer,\r\n  OBSIDIAN_PORTS,\r\n  OBSIDIAN_VERBS,\r\n  OBSIDIAN_PHASES,\r\n  OBSIDIAN_LAYERS,\r\n  PORT_TO_PHASE,\r\n  validateObsidianEvent,\r\n  validatePortVerbConsistency,\r\n  validatePortPhaseConsistency,\r\n  validateTypeVerbConsistency,\r\n  validateSourcePortConsistency,\r\n  validateHiveGenConsistency,\r\n  createObsidianEvent,\r\n  toJsonl,\r\n  fromJsonl,\r\n  parseJsonlFile,\r\n  generateTraceparent,\r\n} from './obsidian-stigmergy';\r\n\r\n// === Arbitraries (Generators) ===\r\n\r\nconst portArb = fc.integer({ min: 0, max: 7 }) as fc.Arbitrary<ObsidianPort>;\r\nconst genArb = fc.integer({ min: 1, max: 1000 });\r\nconst layerArb = fc.constantFrom(...OBSIDIAN_LAYERS) as fc.Arbitrary<ObsidianLayer>;\r\nconst domainArb = fc.stringMatching(/^[a-z]{3,10}$/);\r\nconst actionArb = fc.stringMatching(/^[a-z]{3,10}$/);\r\n\r\nconst dataArb = fc.dictionary(\r\n  fc.string({ minLength: 1, maxLength: 20 }),\r\n  fc.oneof(fc.string(), fc.integer(), fc.boolean(), fc.constant(null))\r\n);\r\n\r\n// Generate a valid OBSIDIAN event\r\nconst validEventArb = fc.tuple(portArb, domainArb, actionArb, genArb, layerArb, dataArb)\r\n  .map(([port, domain, action, gen, layer, data]) => \r\n    createObsidianEvent(port, domain, action, gen, layer, data as Record<string, unknown>)\r\n  );\r\n\r\n// === Property Tests ===\r\n\r\ndescribe('OBSIDIAN Stigmergy Format - Property Tests', () => {\r\n  \r\n  describe('Property 1: Port-Verb Consistency (OBSIDIAN Mapping)', () => {\r\n    /**\r\n     * For any valid port (0-7), the verb MUST match the OBSIDIAN mapping:\r\n     * 0=OBSERVE, 1=BRIDGE, 2=SHAPE, 3=INJECT, 4=DISRUPT, 5=IMMUNIZE, 6=ASSIMILATE, 7=NAVIGATE\r\n     */\r\n    it('port and verb must be consistent for all generated events', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const expectedVerb = OBSIDIAN_PORTS[event.obsidianport];\r\n          expect(event.obsidianverb).toBe(expectedVerb);\r\n          expect(validatePortVerbConsistency(event)).toBe(true);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n\r\n    it('should reject events with mismatched port-verb', () => {\r\n      fc.assert(\r\n        fc.property(portArb, genArb, layerArb, (port, gen, layer) => {\r\n          // Create event with wrong verb\r\n          const wrongVerb = OBSIDIAN_VERBS[(port + 1) % 8];\r\n          const event = createObsidianEvent(port, 'test', 'action', gen, layer, {});\r\n          // Mutate to wrong verb\r\n          const mutatedEvent = { ...event, obsidianverb: wrongVerb };\r\n          expect(validatePortVerbConsistency(mutatedEvent)).toBe(false);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 2: Port-Phase Consistency (HIVE Mapping)', () => {\r\n    /**\r\n     * For any valid port, the phase MUST match the HIVE mapping:\r\n     * H (Hunt): Ports 0, 7\r\n     * I (Interlock): Ports 1, 6\r\n     * V (Validate): Ports 2, 5\r\n     * E (Evolve): Ports 3, 4\r\n     */\r\n    it('port and phase must be consistent for all generated events', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const expectedPhase = PORT_TO_PHASE[event.obsidianport];\r\n          expect(event.obsidianphase).toBe(expectedPhase);\r\n          expect(validatePortPhaseConsistency(event)).toBe(true);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n\r\n  describe('Property 3: Type-Verb Consistency', () => {\r\n    /**\r\n     * For any event, the verb in the type string must match obsidianverb\r\n     * Type format: obsidian.{verb}.{domain}.{action}\r\n     */\r\n    it('event type verb must match obsidianverb', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const verbInType = event.type.split('.')[1].toUpperCase();\r\n          expect(verbInType).toBe(event.obsidianverb);\r\n          expect(validateTypeVerbConsistency(event)).toBe(true);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 4: Source-Port Consistency', () => {\r\n    /**\r\n     * For any event, the port in the source URI must match obsidianport\r\n     * Source format: hfo://gen{N}/{layer}/port/{port}\r\n     */\r\n    it('source URI port must match obsidianport', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const portInSource = parseInt(event.source.split('/port/')[1], 10);\r\n          expect(portInSource).toBe(event.obsidianport);\r\n          expect(validateSourcePortConsistency(event)).toBe(true);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 5: Hive-Gen Consistency', () => {\r\n    /**\r\n     * For any event, the generation in obsidianhive must match obsidiangen\r\n     * Hive format: HFO_GEN{N}\r\n     */\r\n    it('hive generation must match obsidiangen', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const genInHive = parseInt(event.obsidianhive.replace('HFO_GEN', ''), 10);\r\n          expect(genInHive).toBe(event.obsidiangen);\r\n          expect(validateHiveGenConsistency(event)).toBe(true);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 6: Round-Trip Serialization', () => {\r\n    /**\r\n     * For any valid event, serializing to JSONL and parsing back\r\n     * must produce an equivalent event\r\n     */\r\n    it('toJsonl then fromJsonl produces equivalent event', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const jsonl = toJsonl(event);\r\n          const parsed = fromJsonl(jsonl);\r\n          \r\n          // Check all fields match\r\n          expect(parsed.specversion).toBe(event.specversion);\r\n          expect(parsed.id).toBe(event.id);\r\n          expect(parsed.source).toBe(event.source);\r\n          expect(parsed.type).toBe(event.type);\r\n          expect(parsed.obsidianport).toBe(event.obsidianport);\r\n          expect(parsed.obsidianverb).toBe(event.obsidianverb);\r\n          expect(parsed.obsidiangen).toBe(event.obsidiangen);\r\n          expect(parsed.obsidianhive).toBe(event.obsidianhive);\r\n          expect(parsed.obsidianphase).toBe(event.obsidianphase);\r\n          expect(parsed.obsidianlayer).toBe(event.obsidianlayer);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 7: Schema Validation Completeness', () => {\r\n    /**\r\n     * For any valid event created by the factory, schema validation must pass\r\n     */\r\n    it('factory-created events always pass schema validation', () => {\r\n      fc.assert(\r\n        fc.property(validEventArb, (event) => {\r\n          const result = validateObsidianEvent(event);\r\n          expect(result.valid).toBe(true);\r\n          expect(result.errors).toHaveLength(0);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Property 8: Traceparent Format', () => {\r\n    /**\r\n     * Generated traceparent must follow W3C format:\r\n     * 00-{32-hex-trace-id}-{16-hex-span-id}-{2-digit-flags}\r\n     */\r\n    it('traceparent follows W3C format', () => {\r\n      fc.assert(\r\n        fc.property(fc.integer({ min: 1, max: 1000 }), () => {\r\n          const traceparent = generateTraceparent();\r\n          const parts = traceparent.split('-');\r\n          \r\n          expect(parts).toHaveLength(4);\r\n          expect(parts[0]).toBe('00'); // version\r\n          expect(parts[1]).toHaveLength(32); // trace-id\r\n          expect(parts[2]).toHaveLength(16); // span-id\r\n          expect(parts[3]).toHaveLength(2); // flags\r\n          \r\n          // All hex characters\r\n          expect(parts[1]).toMatch(/^[a-f0-9]+$/);\r\n          expect(parts[2]).toMatch(/^[a-f0-9]+$/);\r\n        }),\r\n        { numRuns: 100 }\r\n      );\r\n    });\r\n  });\r\n\r\n  describe('Boundary: Invalid Formats', () => {\r\n    it('should reject invalid source format', () => {\r\n      const event = createObsidianEvent(0, 'hunt', 'research', 88, 'bronze', {});\r\n      const invalidSources = [\r\n        'http://github.com',\r\n        'hfo://gen88',\r\n        'hfo://gen88/bronze',\r\n        'hfo://gen88/bronze/port/8', // port out of range\r\n        'hfo://gen88/gold/port/0',   // layer mismatch\r\n        'prefix_hfo://gen88/bronze/port/0', // anchor test\r\n        'hfo://gen88/bronze/port/0_suffix', // anchor test\r\n      ];\r\n\r\n      invalidSources.forEach(source => {\r\n        const invalidEvent = { ...event, source };\r\n        const result = validateObsidianEvent(invalidEvent);\r\n        expect(result.valid).toBe(false);\r\n        // Kill error push mutants by checking messages\r\n        expect(result.errors.length).toBeGreaterThan(0);\r\n        expect(result.errors.some(e => e.includes('source') || e.includes('Source'))).toBe(true);\r\n      });\r\n    });\r\n\r\n    it('should reject invalid type format', () => {\r\n      const event = createObsidianEvent(0, 'hunt', 'research', 88, 'bronze', {});\r\n      const invalidTypes = [\r\n        'invalid.type',\r\n        'obsidian.SENSE', // missing domain/action\r\n        'obsidian.SENSE.port0', // missing action\r\n        'obsidian.FUSE.hunt.test', // verb mismatch (FUSE vs SENSE)\r\n        'prefix.obsidian.SENSE.hunt.test', // anchor test\r\n        'obsidian.SENSE.hunt.test.suffix', // anchor test\r\n      ];\r\n\r\n      invalidTypes.forEach(type => {\r\n        const invalidEvent = { ...event, type };\r\n        const result = validateObsidianEvent(invalidEvent);\r\n        expect(result.valid).toBe(false);\r\n        expect(result.errors.some(e => e.includes('type') || e.includes('Type'))).toBe(true);\r\n      });\r\n    });\r\n\r\n    it('should reject invalid hive format', () => {\r\n      const event = createObsidianEvent(0, 'hunt', 'research', 88, 'bronze', {});\r\n      const invalidHives = [\r\n        'GEN88',\r\n        'hfo_gen88',\r\n        'HFO_GEN89', // generation mismatch\r\n        'PRE_HFO_GEN88', // anchor test\r\n        'HFO_GEN88_POST', // anchor test\r\n      ];\r\n\r\n      invalidHives.forEach(obsidianhive => {\r\n        const invalidEvent = { ...event, obsidianhive };\r\n        const result = validateObsidianEvent(invalidEvent);\r\n        expect(result.valid).toBe(false);\r\n        expect(result.errors.some(e => e.includes('hive') || e.includes('Hive'))).toBe(true);\r\n      });\r\n    });\r\n  });\r\n\r\n  describe('Property 9: Traceparent Character Distribution', () => {\r\n    it('generates IDs with varying characters (kills math mutants)', () => {\r\n      for (let i = 0; i < 10; i++) {\r\n        const tp = generateTraceparent();\r\n        const parts = tp.split('-');\r\n        const traceId = parts[1];\r\n        const spanId = parts[2];\r\n        \r\n        // If Math.random() logic is broken, we might get all 0s or similar\r\n        const uniqueTraceChars = new Set(traceId.split('')).size;\r\n        const uniqueSpanChars = new Set(spanId.split('')).size;\r\n        \r\n        // Statistically extremely likely to have > 1 unique char in 32/16 hex chars\r\n        expect(uniqueTraceChars).toBeGreaterThan(1);\r\n        expect(uniqueSpanChars).toBeGreaterThan(1);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Integration: File Parsing', () => {\r\n    it('should parse multiple events from JSONL string', () => {\r\n      const events = [\r\n        createObsidianEvent(0, 'test', 'one', 1, 'bronze', {}),\r\n        createObsidianEvent(1, 'test', 'two', 1, 'bronze', {}),\r\n      ];\r\n      const content = events.map(e => toJsonl(e)).join('\\n');\r\n      \r\n      const parsed = parseJsonlFile(content);\r\n      expect(parsed).toHaveLength(2);\r\n      expect(parsed[0].id).toBe(events[0].id);\r\n      expect(parsed[1].id).toBe(events[1].id);\r\n    });\r\n\r\n    it('should ignore empty lines in JSONL', () => {\r\n      const event = createObsidianEvent(0, 'test', 'one', 1, 'bronze', {});\r\n      const content = `\\n${toJsonl(event)}\\n\\n`;\r\n      const parsed = parseJsonlFile(content);\r\n      expect(parsed).toHaveLength(1);\r\n    });\r\n  });\r\n});\r\n\r\n\r\n// === Mutation Tests (Negative Cases) ===\r\n\r\ndescribe('OBSIDIAN Stigmergy Format - Mutation Tests', () => {\r\n  \r\n  describe('Mutation 1: Invalid Port Values', () => {\r\n    it('should reject port values outside 0-7', () => {\r\n      const invalidPorts = [-1, 8, 100, -100];\r\n      \r\n      for (const port of invalidPorts) {\r\n        const event = {\r\n          specversion: '1.0',\r\n          id: crypto.randomUUID(),\r\n          source: `hfo://gen88/bronze/port/0`,\r\n          type: 'obsidian.observe.test.action',\r\n          time: new Date().toISOString(),\r\n          datacontenttype: 'application/json',\r\n          traceparent: generateTraceparent(),\r\n          obsidianport: port,\r\n          obsidianverb: 'OBSERVE',\r\n          obsidiangen: 88,\r\n          obsidianhive: 'HFO_GEN88',\r\n          obsidianphase: 'H',\r\n          obsidianlayer: 'bronze',\r\n          data: {},\r\n        };\r\n        \r\n        const result = validateObsidianEvent(event);\r\n        expect(result.valid).toBe(false);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Mutation 2: Invalid Verb Values', () => {\r\n    it('should reject verbs not in OBSIDIAN set', () => {\r\n      const invalidVerbs = ['SENSE', 'FUSE', 'STORE', 'DECIDE', 'ATTACK', 'DELETE'];\r\n      \r\n      for (const verb of invalidVerbs) {\r\n        const event = {\r\n          specversion: '1.0',\r\n          id: crypto.randomUUID(),\r\n          source: `hfo://gen88/bronze/port/0`,\r\n          type: 'obsidian.observe.test.action',\r\n          time: new Date().toISOString(),\r\n          datacontenttype: 'application/json',\r\n          traceparent: generateTraceparent(),\r\n          obsidianport: 0,\r\n          obsidianverb: verb,\r\n          obsidiangen: 88,\r\n          obsidianhive: 'HFO_GEN88',\r\n          obsidianphase: 'H',\r\n          obsidianlayer: 'bronze',\r\n          data: {},\r\n        };\r\n        \r\n        const result = validateObsidianEvent(event);\r\n        expect(result.valid).toBe(false);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Mutation 3: Mismatched Port-Verb', () => {\r\n    it('should reject events where port does not match verb', () => {\r\n      // Port 0 should be OBSERVE, not BRIDGE\r\n      const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', {});\r\n      const mutated = { ...event, obsidianverb: 'BRIDGE' as const };\r\n      \r\n      const result = validateObsidianEvent(mutated);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Port 0 must use verb OBSERVE'))).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Mutation 4: Mismatched Port-Phase', () => {\r\n    it('should reject events where port does not match phase', () => {\r\n      // Port 0 should be phase H, not E\r\n      const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', {});\r\n      const mutated = { ...event, obsidianphase: 'E' as const };\r\n      \r\n      const result = validateObsidianEvent(mutated);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Port 0 must use phase H'))).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('Mutation 5: Invalid Traceparent Format', () => {\r\n    it('should reject malformed traceparent', () => {\r\n      const invalidTraceparents = [\r\n        'invalid',\r\n        '00-abc-def-01', // too short\r\n        '01-aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa-bbbbbbbbbbbbbbbb-01', // wrong version\r\n        '00-GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG-bbbbbbbbbbbbbbbb-01', // invalid hex\r\n      ];\r\n      \r\n      for (const traceparent of invalidTraceparents) {\r\n        const event = {\r\n          specversion: '1.0' as const,\r\n          id: crypto.randomUUID(),\r\n          source: `hfo://gen88/bronze/port/0`,\r\n          type: 'obsidian.observe.test.action',\r\n          time: new Date().toISOString(),\r\n          datacontenttype: 'application/json' as const,\r\n          traceparent,\r\n          obsidianport: 0 as const,\r\n          obsidianverb: 'OBSERVE' as const,\r\n          obsidiangen: 88,\r\n          obsidianhive: 'HFO_GEN88',\r\n          obsidianphase: 'H' as const,\r\n          obsidianlayer: 'bronze' as const,\r\n          data: {},\r\n        };\r\n        \r\n        const result = validateObsidianEvent(event);\r\n        expect(result.valid).toBe(false);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Mutation 6: Invalid Source URI', () => {\r\n    it('should reject malformed source URIs', () => {\r\n      const invalidSources = [\r\n        'invalid',\r\n        'hfo://gen88/bronze', // missing port\r\n        'hfo://gen88/bronze/port/9', // port out of range\r\n        'http://gen88/bronze/port/0', // wrong protocol\r\n        'hfo://gen88/platinum/port/0', // invalid layer\r\n      ];\r\n      \r\n      for (const source of invalidSources) {\r\n        const event = {\r\n          specversion: '1.0' as const,\r\n          id: crypto.randomUUID(),\r\n          source,\r\n          type: 'obsidian.observe.test.action',\r\n          time: new Date().toISOString(),\r\n          datacontenttype: 'application/json' as const,\r\n          traceparent: generateTraceparent(),\r\n          obsidianport: 0 as const,\r\n          obsidianverb: 'OBSERVE' as const,\r\n          obsidiangen: 88,\r\n          obsidianhive: 'HFO_GEN88',\r\n          obsidianphase: 'H' as const,\r\n          obsidianlayer: 'bronze' as const,\r\n          data: {},\r\n        };\r\n        \r\n        const result = validateObsidianEvent(event);\r\n        expect(result.valid).toBe(false);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Mutation 7: Invalid Event Type Format', () => {\r\n    it('should reject malformed event types', () => {\r\n      const invalidTypes = [\r\n        'invalid',\r\n        'obsidian.observe', // missing domain.action\r\n        'obsidian.OBSERVE.test.action', // uppercase verb\r\n        'cloudevents.observe.test.action', // wrong prefix\r\n        'obsidian.attack.test.action', // invalid verb\r\n      ];\r\n      \r\n      for (const type of invalidTypes) {\r\n        const event = {\r\n          specversion: '1.0' as const,\r\n          id: crypto.randomUUID(),\r\n          source: `hfo://gen88/bronze/port/0`,\r\n          type,\r\n          time: new Date().toISOString(),\r\n          datacontenttype: 'application/json' as const,\r\n          traceparent: generateTraceparent(),\r\n          obsidianport: 0 as const,\r\n          obsidianverb: 'OBSERVE' as const,\r\n          obsidiangen: 88,\r\n          obsidianhive: 'HFO_GEN88',\r\n          obsidianphase: 'H' as const,\r\n          obsidianlayer: 'bronze' as const,\r\n          data: {},\r\n        };\r\n        \r\n        const result = validateObsidianEvent(event);\r\n        expect(result.valid).toBe(false);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('Mutation 8: Mismatched Hive-Gen', () => {\r\n    it('should reject events where hive does not match gen', () => {\r\n      const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', {});\r\n      const mutated = { ...event, obsidianhive: 'HFO_GEN99' };\r\n      \r\n      const result = validateObsidianEvent(mutated);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Hive generation must match'))).toBe(true);\r\n    });\r\n  });\r\n});\r\n\r\n// === Edge Case Tests ===\r\n\r\ndescribe('OBSIDIAN Stigmergy Format - Edge Cases', () => {\r\n  \r\n  it('should handle empty data payload', () => {\r\n    const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', {});\r\n    const result = validateObsidianEvent(event);\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  it('should handle complex nested data payload', () => {\r\n    const complexData = {\r\n      nested: { deep: { value: 123 } },\r\n      array: [1, 2, 3],\r\n      mixed: [{ a: 1 }, 'string', null],\r\n    };\r\n    const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', complexData);\r\n    const result = validateObsidianEvent(event);\r\n    expect(result.valid).toBe(true);\r\n  });\r\n\r\n  it('should handle all 8 ports correctly', () => {\r\n    for (let port = 0; port <= 7; port++) {\r\n      const event = createObsidianEvent(port as ObsidianPort, 'test', 'action', 88, 'bronze', {});\r\n      const result = validateObsidianEvent(event);\r\n      expect(result.valid).toBe(true);\r\n      expect(event.obsidianverb).toBe(OBSIDIAN_PORTS[port as ObsidianPort]);\r\n      expect(event.obsidianphase).toBe(PORT_TO_PHASE[port]);\r\n    }\r\n  });\r\n\r\n  it('should handle all 3 layers correctly', () => {\r\n    for (const layer of OBSIDIAN_LAYERS) {\r\n      const event = createObsidianEvent(0, 'test', 'action', 88, layer, {});\r\n      const result = validateObsidianEvent(event);\r\n      expect(result.valid).toBe(true);\r\n      expect(event.obsidianlayer).toBe(layer);\r\n    }\r\n  });\r\n\r\n  it('should handle BDD fields (given/when/then)', () => {\r\n    const event = createObsidianEvent(0, 'test', 'action', 88, 'bronze', {}, {\r\n      given: 'a file exists',\r\n      when: 'observed',\r\n      then: 'metadata extracted',\r\n    });\r\n    const result = validateObsidianEvent(event);\r\n    expect(result.valid).toBe(true);\r\n    expect(event.given).toBe('a file exists');\r\n    expect(event.when).toBe('observed');\r\n    expect(event.then).toBe('metadata extracted');\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P1_WEB_WEAVER/WEB_WEAVER.property.test.ts":{"tests":[{"id":"165","name":"Property 4: Message Bridging Validation bridge returns success for all valid messages"},{"id":"166","name":"Property 4: Message Bridging Validation bridge returns failure for all invalid messages"},{"id":"167","name":"Property 4: Message Bridging Validation bridged messages preserve data integrity"},{"id":"168","name":"VacuoleEnvelope Schema Validation all valid envelopes pass schema validation"},{"id":"169","name":"VacuoleEnvelope Schema Validation wrapEnvelope creates valid envelopes for all inputs"},{"id":"170","name":"SilverPromotionReceipt Schema Validation all valid receipts pass schema validation"},{"id":"171","name":"SilverPromotionReceipt Schema Validation receipts with score < 80 fail validation"},{"id":"172","name":"SilverPromotionReceipt Schema Validation receipts with score > 98.99 fail validation"},{"id":"173","name":"Fuse Schema Composition fused schemas accept objects with all required fields"},{"id":"174","name":"Fuse Schema Composition fused schemas reject objects missing fields from either schema"},{"id":"175","name":"StigmergyEvent Schema Validation validates all eventType enum values"},{"id":"176","name":"StigmergyEvent Schema Validation rejects invalid eventType values"},{"id":"177","name":"StigmergyEvent Schema Validation validates sourcePort bounds (0-7)"},{"id":"178","name":"StigmergyEvent Schema Validation validates correlationId is optional"},{"id":"179","name":"StigmergyEvent Schema Validation all valid stigmergy events pass validation"}],"source":"/**\r\n * P1 WEB WEAVER - Property-Based Tests\r\n * \r\n * @port 1\r\n * @commander WEB_WEAVER\r\n * @provenance: design.md\r\n * Validates: Requirements 3.6\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport * as fc from 'fast-check';\r\nimport { z } from 'zod';\r\nimport {\r\n  bridge,\r\n  fuse,\r\n  wrapEnvelope,\r\n  VacuoleEnvelopeSchema,\r\n  SilverPromotionReceiptSchema,\r\n  StigmergyEventSchema,\r\n} from './contracts/index.js';\r\n\r\n// --- Property 4: Message Bridging Validation ---\r\n// Feature: legendary-commanders-gen88, Property 4: Message Bridging Validation\r\n\r\ndescribe('Property 4: Message Bridging Validation', () => {\r\n  \r\n  it('bridge returns success for all valid messages', () => {\r\n    const schema = z.object({\r\n      name: z.string(),\r\n      value: z.number(),\r\n    });\r\n\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          name: fc.string({ minLength: 1 }),\r\n          value: fc.double({ noNaN: true }),\r\n        }),\r\n        (message) => {\r\n          const result = bridge(message, schema);\r\n          expect(result.success).toBe(true);\r\n          if (result.success) {\r\n            expect(result.data.name).toBe(message.name);\r\n            expect(result.data.value).toBe(message.value);\r\n          }\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('bridge returns failure for all invalid messages', () => {\r\n    const schema = z.object({\r\n      name: z.string(),\r\n      value: z.number(),\r\n    });\r\n\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          name: fc.nat(), // Wrong type\r\n          value: fc.string(), // Wrong type\r\n        }),\r\n        (message) => {\r\n          const result = bridge(message, schema);\r\n          expect(result.success).toBe(false);\r\n          if (!result.success) {\r\n            expect(result.errors.length).toBeGreaterThan(0);\r\n          }\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('bridged messages preserve data integrity', () => {\r\n    const schema = z.object({\r\n      id: z.string(),\r\n      count: z.number(),\r\n      active: z.boolean(),\r\n    });\r\n\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          id: fc.string({ minLength: 1 }),\r\n          count: fc.integer(),\r\n          active: fc.boolean(),\r\n        }),\r\n        (message) => {\r\n          const result = bridge(message, schema);\r\n          expect(result.success).toBe(true);\r\n          if (result.success) {\r\n            expect(result.data).toEqual(message);\r\n          }\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- VacuoleEnvelope Validation ---\r\n\r\ndescribe('VacuoleEnvelope Schema Validation', () => {\r\n  \r\n  const envelopeArb = fc.record({\r\n    id: fc.uuid(),\r\n    timestamp: fc.nat(),\r\n    sourcePort: fc.integer({ min: 0, max: 7 }),\r\n    targetPort: fc.integer({ min: 0, max: 7 }),\r\n    verb: fc.constantFrom('OBSERVE', 'BRIDGE', 'SHAPE', 'INJECT', 'DISRUPT', 'IMMUNIZE', 'ASSIMILATE', 'NAVIGATE'),\r\n    payload: fc.anything(),\r\n    metadata: fc.record({\r\n      ttl: fc.nat(),\r\n      priority: fc.constantFrom('low', 'normal', 'high', 'critical'),\r\n      correlationId: fc.option(fc.string(), { nil: undefined }),\r\n    }),\r\n  });\r\n\r\n  it('all valid envelopes pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(envelopeArb, (envelope) => {\r\n        const result = VacuoleEnvelopeSchema.safeParse(envelope);\r\n        expect(result.success).toBe(true);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('wrapEnvelope creates valid envelopes for all inputs', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.integer({ min: 0, max: 7 }),\r\n        fc.integer({ min: 0, max: 7 }),\r\n        fc.constantFrom('OBSERVE', 'BRIDGE', 'SHAPE', 'INJECT', 'DISRUPT', 'IMMUNIZE', 'ASSIMILATE', 'NAVIGATE'),\r\n        fc.anything(),\r\n        fc.constantFrom('low', 'normal', 'high', 'critical'),\r\n        (source, target, verb, payload, priority) => {\r\n          const envelope = wrapEnvelope(source, target, verb, payload, priority);\r\n          const result = VacuoleEnvelopeSchema.safeParse(envelope);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- SilverPromotionReceipt Validation ---\r\n\r\ndescribe('SilverPromotionReceipt Schema Validation', () => {\r\n  \r\n  const hexCharArb = fc.constantFrom(...'0123456789abcdef'.split(''));\r\n  const hex64Arb = fc.array(hexCharArb, { minLength: 64, maxLength: 64 }).map(arr => arr.join(''));\r\n\r\n  const receiptArb = fc.record({\r\n    artifact: fc.string({ minLength: 1 }),\r\n    mutationScore: fc.double({ min: 80, max: 98.99, noNaN: true }),\r\n    timestamp: fc.string({ minLength: 1 }),\r\n    hash: hex64Arb.map(h => `sha256:${h}`),\r\n    strykerConfig: fc.string({ minLength: 1 }),\r\n    propertyTestsPassed: fc.boolean(),\r\n    zodContractsPresent: fc.boolean(),\r\n    provenanceHeadersPresent: fc.boolean(),\r\n  });\r\n\r\n  it('all valid receipts pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(receiptArb, (receipt) => {\r\n        const result = SilverPromotionReceiptSchema.safeParse(receipt);\r\n        expect(result.success).toBe(true);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('receipts with score < 80 fail validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          mutationScore: fc.double({ min: 0, max: 79.99, noNaN: true }),\r\n          timestamp: fc.string({ minLength: 1 }),\r\n          hash: hex64Arb.map(h => `sha256:${h}`),\r\n          strykerConfig: fc.string({ minLength: 1 }),\r\n          propertyTestsPassed: fc.boolean(),\r\n          zodContractsPresent: fc.boolean(),\r\n          provenanceHeadersPresent: fc.boolean(),\r\n        }),\r\n        (receipt) => {\r\n          const result = SilverPromotionReceiptSchema.safeParse(receipt);\r\n          expect(result.success).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('receipts with score > 98.99 fail validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          mutationScore: fc.double({ min: 99, max: 100, noNaN: true }),\r\n          timestamp: fc.string({ minLength: 1 }),\r\n          hash: hex64Arb.map(h => `sha256:${h}`),\r\n          strykerConfig: fc.string({ minLength: 1 }),\r\n          propertyTestsPassed: fc.boolean(),\r\n          zodContractsPresent: fc.boolean(),\r\n          provenanceHeadersPresent: fc.boolean(),\r\n        }),\r\n        (receipt) => {\r\n          const result = SilverPromotionReceiptSchema.safeParse(receipt);\r\n          expect(result.success).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Fuse Schema Composition ---\r\n\r\ndescribe('Fuse Schema Composition', () => {\r\n  \r\n  it('fused schemas accept objects with all required fields', () => {\r\n    const schemaA = z.object({ a: z.string() });\r\n    const schemaB = z.object({ b: z.number() });\r\n    const fused = fuse(schemaA, schemaB);\r\n\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          a: fc.string(),\r\n          b: fc.double({ noNaN: true }),\r\n        }),\r\n        (obj) => {\r\n          const result = fused.safeParse(obj);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('fused schemas reject objects missing fields from either schema', () => {\r\n    const schemaA = z.object({ a: z.string() });\r\n    const schemaB = z.object({ b: z.number() });\r\n    const fused = fuse(schemaA, schemaB);\r\n\r\n    // Missing 'b'\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({ a: fc.string() }),\r\n        (obj) => {\r\n          const result = fused.safeParse(obj);\r\n          expect(result.success).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n\r\n// --- StigmergyEvent Schema Validation (Killing Surviving Mutants) ---\r\n\r\ndescribe('StigmergyEvent Schema Validation', () => {\r\n  \r\n  // Test ALL eventType values to kill string literal mutants\r\n  const allEventTypes = [\r\n    'OBSERVATION', 'BRIDGE', 'TRANSFORM', 'INJECTION',\r\n    'VIOLATION', 'IMMUNIZATION', 'ASSIMILATION', 'DECISION',\r\n    'PROMOTION', 'DEMOTION', 'REBIRTH'\r\n  ] as const;\r\n\r\n  it('validates all eventType enum values', () => {\r\n    for (const eventType of allEventTypes) {\r\n      const event = {\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        sourcePort: 1,\r\n        eventType,\r\n        payload: { test: 'data' },\r\n      };\r\n      const result = StigmergyEventSchema.safeParse(event);\r\n      expect(result.success, `eventType \"${eventType}\" should be valid`).toBe(true);\r\n    }\r\n  });\r\n\r\n  it('rejects invalid eventType values', () => {\r\n    const invalidTypes = ['INVALID', '', 'observation', 'OBSERVE'];\r\n    for (const eventType of invalidTypes) {\r\n      const event = {\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        sourcePort: 1,\r\n        eventType,\r\n        payload: {},\r\n      };\r\n      const result = StigmergyEventSchema.safeParse(event);\r\n      expect(result.success, `eventType \"${eventType}\" should be invalid`).toBe(false);\r\n    }\r\n  });\r\n\r\n  it('validates sourcePort bounds (0-7)', () => {\r\n    // Valid ports\r\n    for (let port = 0; port <= 7; port++) {\r\n      const event = {\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        sourcePort: port,\r\n        eventType: 'BRIDGE' as const,\r\n        payload: {},\r\n      };\r\n      const result = StigmergyEventSchema.safeParse(event);\r\n      expect(result.success, `port ${port} should be valid`).toBe(true);\r\n    }\r\n    \r\n    // Invalid ports\r\n    for (const port of [-1, 8, 100]) {\r\n      const event = {\r\n        id: crypto.randomUUID(),\r\n        timestamp: Date.now(),\r\n        sourcePort: port,\r\n        eventType: 'BRIDGE' as const,\r\n        payload: {},\r\n      };\r\n      const result = StigmergyEventSchema.safeParse(event);\r\n      expect(result.success, `port ${port} should be invalid`).toBe(false);\r\n    }\r\n  });\r\n\r\n  it('validates correlationId is optional', () => {\r\n    const withCorrelation = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: Date.now(),\r\n      sourcePort: 1,\r\n      eventType: 'PROMOTION' as const,\r\n      payload: {},\r\n      correlationId: 'corr-123',\r\n    };\r\n    expect(StigmergyEventSchema.safeParse(withCorrelation).success).toBe(true);\r\n\r\n    const withoutCorrelation = {\r\n      id: crypto.randomUUID(),\r\n      timestamp: Date.now(),\r\n      sourcePort: 1,\r\n      eventType: 'DEMOTION' as const,\r\n      payload: {},\r\n    };\r\n    expect(StigmergyEventSchema.safeParse(withoutCorrelation).success).toBe(true);\r\n  });\r\n\r\n  // Property test for all valid combinations\r\n  it('all valid stigmergy events pass validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          id: fc.uuid(),\r\n          timestamp: fc.nat(),\r\n          sourcePort: fc.integer({ min: 0, max: 7 }),\r\n          eventType: fc.constantFrom(...allEventTypes),\r\n          payload: fc.anything(),\r\n          correlationId: fc.option(fc.string(), { nil: undefined }),\r\n        }),\r\n        (event) => {\r\n          const result = StigmergyEventSchema.safeParse(event);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P7_SPIDER_SOVEREIGN/SPIDER_SOVEREIGN.property.test.ts":{"tests":[{"id":"180","name":"Property 15: Hybrid Consensus Correctness returns hybrid_agree when critique matches weighted majority"},{"id":"181","name":"Property 15: Hybrid Consensus Correctness returns weighted_majority when agreement >= 50% and critique disagrees"},{"id":"182","name":"Property 15: Hybrid Consensus Correctness returns critique_confident when low agreement but high critique confidence"},{"id":"183","name":"Property 15: Hybrid Consensus Correctness always returns a valid consensus method"},{"id":"184","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings H phase uses ports 0+7 (anti-diagonal)"},{"id":"185","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings I phase uses ports 1+6 (anti-diagonal)"},{"id":"186","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings V phase uses ports 2+5 (anti-diagonal)"},{"id":"187","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings E phase uses ports 3+4 (anti-diagonal)"},{"id":"188","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings all HIVE pairings satisfy anti-diagonal property (sum = 7)"},{"id":"189","name":"Property 13: Workflow Pairing Correctness HIVE/8 Anti-Diagonal Pairings rejects incorrect HIVE pairings"},{"id":"190","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings P phase uses ports 0+6 (serpentine)"},{"id":"191","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings R phase uses ports 1+7 (serpentine)"},{"id":"192","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings E phase uses ports 2+4 (serpentine)"},{"id":"193","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings Y phase uses ports 3+5 (serpentine)"},{"id":"194","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings all PREY pairings are valid"},{"id":"195","name":"Property 13: Workflow Pairing Correctness PREY/8 Serpentine Pairings rejects incorrect PREY pairings"},{"id":"196","name":"Property 16: Decision Schema Validation valid decisions pass schema validation"},{"id":"197","name":"Property 16: Decision Schema Validation decisions with invalid method fail validation"},{"id":"198","name":"Property 16: Decision Schema Validation valid votes pass schema validation"}],"source":"/**\r\n * P7 SPIDER SOVEREIGN - Property-Based Tests\r\n * \r\n * @port 7\r\n * @commander SPIDER_SOVEREIGN\r\n * @provenance: design.md\r\n * Validates: Requirements 9.5, 9.6, 9.7, 12.3, 12.4\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport * as fc from 'fast-check';\r\nimport {\r\n  hybridConsensus,\r\n  computeWeightedVoting,\r\n  isValidHivePairing,\r\n  isValidPreyPairing,\r\n  HIVE_PAIRINGS,\r\n  PREY_PAIRINGS,\r\n  DecisionSchema,\r\n  VoteSchema,\r\n  ConsensusMethodSchema,\r\n} from './contracts/index.js';\r\n\r\n// --- Property 15: Hybrid Consensus Correctness ---\r\n// Feature: legendary-commanders-gen88, Property 15: Hybrid Consensus Correctness\r\n\r\ndescribe('Property 15: Hybrid Consensus Correctness', () => {\r\n  \r\n  const voteArb = fc.record({\r\n    model: fc.string({ minLength: 1 }),\r\n    answer: fc.constantFrom('A', 'B', 'C', 'D'),\r\n    weight: fc.double({ min: 0, max: 1, noNaN: true }),\r\n  });\r\n\r\n  it('returns hybrid_agree when critique matches weighted majority', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.array(voteArb, { minLength: 3, maxLength: 8 }),\r\n        (votes) => {\r\n          const weighted = computeWeightedVoting(votes);\r\n          if (weighted.answer === '') return true; // Skip empty\r\n          \r\n          const result = hybridConsensus({\r\n            votes,\r\n            critiqueAnswer: weighted.answer, // Critique agrees\r\n            critiqueConfidence: 0.9,\r\n          });\r\n          \r\n          expect(result.method).toBe('hybrid_agree');\r\n          expect(result.answer).toBe(weighted.answer);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('returns weighted_majority when agreement >= 50% and critique disagrees', () => {\r\n    // Create votes where one answer has majority\r\n    const majorityVotesArb = fc.tuple(\r\n      fc.constantFrom('A', 'B', 'C'),\r\n      fc.constantFrom('A', 'B', 'C'),\r\n    ).filter(([majority, critique]) => majority !== critique)\r\n    .chain(([majority, critique]) => {\r\n      // Create 6 votes where majority answer has 4+ votes (66%+)\r\n      const majorityVotes = fc.array(\r\n        fc.record({\r\n          model: fc.string({ minLength: 1 }),\r\n          answer: fc.constant(majority),\r\n          weight: fc.constant(1),\r\n        }),\r\n        { minLength: 4, maxLength: 4 }\r\n      );\r\n      const minorityVotes = fc.array(\r\n        fc.record({\r\n          model: fc.string({ minLength: 1 }),\r\n          answer: fc.constantFrom('A', 'B', 'C').filter(a => a !== majority),\r\n          weight: fc.constant(1),\r\n        }),\r\n        { minLength: 2, maxLength: 2 }\r\n      );\r\n      return fc.tuple(\r\n        majorityVotes,\r\n        minorityVotes,\r\n        fc.constant(critique),\r\n      );\r\n    });\r\n\r\n    fc.assert(\r\n      fc.property(majorityVotesArb, ([majorityVotes, minorityVotes, critique]) => {\r\n        const votes = [...majorityVotes, ...minorityVotes];\r\n        const weighted = computeWeightedVoting(votes);\r\n        \r\n        if (weighted.agreement < 0.5) return true; // Skip if not majority\r\n        \r\n        const result = hybridConsensus({\r\n          votes,\r\n          critiqueAnswer: critique,\r\n          critiqueConfidence: 0.5, // Low confidence\r\n        });\r\n        \r\n        expect(result.method).toBe('weighted_majority');\r\n        expect(result.answer).toBe(weighted.answer);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('returns critique_confident when low agreement but high critique confidence', () => {\r\n    // Create evenly split votes (low agreement)\r\n    const splitVotesArb = fc.tuple(\r\n      fc.array(\r\n        fc.record({\r\n          model: fc.string({ minLength: 1 }),\r\n          answer: fc.constant('A'),\r\n          weight: fc.constant(1),\r\n        }),\r\n        { minLength: 2, maxLength: 2 }\r\n      ),\r\n      fc.array(\r\n        fc.record({\r\n          model: fc.string({ minLength: 1 }),\r\n          answer: fc.constant('B'),\r\n          weight: fc.constant(1),\r\n        }),\r\n        { minLength: 2, maxLength: 2 }\r\n      ),\r\n      fc.array(\r\n        fc.record({\r\n          model: fc.string({ minLength: 1 }),\r\n          answer: fc.constant('C'),\r\n          weight: fc.constant(1),\r\n        }),\r\n        { minLength: 2, maxLength: 2 }\r\n      ),\r\n    );\r\n\r\n    fc.assert(\r\n      fc.property(splitVotesArb, ([votesA, votesB, votesC]) => {\r\n        const votes = [...votesA, ...votesB, ...votesC];\r\n        const weighted = computeWeightedVoting(votes);\r\n        \r\n        // Agreement should be ~33% (low)\r\n        if (weighted.agreement >= 0.5) return true;\r\n        \r\n        const result = hybridConsensus({\r\n          votes,\r\n          critiqueAnswer: 'D', // Different from all\r\n          critiqueConfidence: 0.9, // High confidence\r\n        });\r\n        \r\n        expect(result.method).toBe('critique_confident');\r\n        expect(result.answer).toBe('D');\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('always returns a valid consensus method', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.array(voteArb, { minLength: 1, maxLength: 10 }),\r\n        fc.constantFrom('A', 'B', 'C', 'D'),\r\n        fc.double({ min: 0, max: 1, noNaN: true }),\r\n        (votes, critiqueAnswer, critiqueConfidence) => {\r\n          const result = hybridConsensus({\r\n            votes,\r\n            critiqueAnswer,\r\n            critiqueConfidence,\r\n          });\r\n          \r\n          const validMethods = ['hybrid_agree', 'weighted_majority', 'critique_confident', 'weighted_default'];\r\n          expect(validMethods).toContain(result.method);\r\n          expect(result.confidence).toBeGreaterThanOrEqual(0);\r\n          expect(result.confidence).toBeLessThanOrEqual(1);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Property 13: Workflow Pairing Correctness ---\r\n// Feature: legendary-commanders-gen88, Property 13: Workflow Pairing Correctness\r\n\r\ndescribe('Property 13: Workflow Pairing Correctness', () => {\r\n  \r\n  describe('HIVE/8 Anti-Diagonal Pairings', () => {\r\n    \r\n    it('H phase uses ports 0+7 (anti-diagonal)', () => {\r\n      expect(isValidHivePairing('H', [0, 7])).toBe(true);\r\n      expect(isValidHivePairing('H', [7, 0])).toBe(true); // Order doesn't matter\r\n      expect(0 + 7).toBe(7); // Anti-diagonal property\r\n    });\r\n\r\n    it('I phase uses ports 1+6 (anti-diagonal)', () => {\r\n      expect(isValidHivePairing('I', [1, 6])).toBe(true);\r\n      expect(isValidHivePairing('I', [6, 1])).toBe(true);\r\n      expect(1 + 6).toBe(7);\r\n    });\r\n\r\n    it('V phase uses ports 2+5 (anti-diagonal)', () => {\r\n      expect(isValidHivePairing('V', [2, 5])).toBe(true);\r\n      expect(isValidHivePairing('V', [5, 2])).toBe(true);\r\n      expect(2 + 5).toBe(7);\r\n    });\r\n\r\n    it('E phase uses ports 3+4 (anti-diagonal)', () => {\r\n      expect(isValidHivePairing('E', [3, 4])).toBe(true);\r\n      expect(isValidHivePairing('E', [4, 3])).toBe(true);\r\n      expect(3 + 4).toBe(7);\r\n    });\r\n\r\n    it('all HIVE pairings satisfy anti-diagonal property (sum = 7)', () => {\r\n      for (const [phase, ports] of Object.entries(HIVE_PAIRINGS)) {\r\n        const [a, b] = ports;\r\n        expect(a + b).toBe(7);\r\n        expect(isValidHivePairing(phase as keyof typeof HIVE_PAIRINGS, [a, b])).toBe(true);\r\n      }\r\n    });\r\n\r\n    it('rejects incorrect HIVE pairings', () => {\r\n      expect(isValidHivePairing('H', [0, 6])).toBe(false); // Wrong pair\r\n      expect(isValidHivePairing('H', [1, 7])).toBe(false); // Wrong pair\r\n      expect(isValidHivePairing('I', [0, 7])).toBe(false); // Wrong phase\r\n    });\r\n  });\r\n\r\n  describe('PREY/8 Serpentine Pairings', () => {\r\n    \r\n    it('P phase uses ports 0+6 (serpentine)', () => {\r\n      expect(isValidPreyPairing('P', [0, 6])).toBe(true);\r\n      expect(isValidPreyPairing('P', [6, 0])).toBe(true);\r\n    });\r\n\r\n    it('R phase uses ports 1+7 (serpentine)', () => {\r\n      expect(isValidPreyPairing('R', [1, 7])).toBe(true);\r\n      expect(isValidPreyPairing('R', [7, 1])).toBe(true);\r\n    });\r\n\r\n    it('E phase uses ports 2+4 (serpentine)', () => {\r\n      expect(isValidPreyPairing('E', [2, 4])).toBe(true);\r\n      expect(isValidPreyPairing('E', [4, 2])).toBe(true);\r\n    });\r\n\r\n    it('Y phase uses ports 3+5 (serpentine)', () => {\r\n      expect(isValidPreyPairing('Y', [3, 5])).toBe(true);\r\n      expect(isValidPreyPairing('Y', [5, 3])).toBe(true);\r\n    });\r\n\r\n    it('all PREY pairings are valid', () => {\r\n      for (const [phase, ports] of Object.entries(PREY_PAIRINGS)) {\r\n        const [a, b] = ports;\r\n        expect(isValidPreyPairing(phase as keyof typeof PREY_PAIRINGS, [a, b])).toBe(true);\r\n      }\r\n    });\r\n\r\n    it('rejects incorrect PREY pairings', () => {\r\n      expect(isValidPreyPairing('P', [0, 7])).toBe(false); // Wrong pair\r\n      expect(isValidPreyPairing('R', [0, 6])).toBe(false); // Wrong phase\r\n    });\r\n  });\r\n});\r\n\r\n// --- Property 16: Decision Logging Invariant ---\r\n// Feature: legendary-commanders-gen88, Property 16: Decision Logging Invariant\r\n\r\ndescribe('Property 16: Decision Schema Validation', () => {\r\n  \r\n  const voteArb = fc.record({\r\n    model: fc.string({ minLength: 1 }),\r\n    answer: fc.string({ minLength: 1 }),\r\n    weight: fc.double({ min: 0, max: 1, noNaN: true }),\r\n  });\r\n\r\n  it('valid decisions pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          id: fc.uuid(),\r\n          timestamp: fc.nat(),\r\n          question: fc.string({ minLength: 1 }),\r\n          answer: fc.string({ minLength: 1 }),\r\n          confidence: fc.double({ min: 0, max: 1, noNaN: true }),\r\n          method: fc.constantFrom('hybrid_agree', 'weighted_majority', 'critique_confident', 'weighted_default'),\r\n          votes: fc.array(voteArb, { minLength: 1, maxLength: 10 }),\r\n        }),\r\n        (decision) => {\r\n          const result = DecisionSchema.safeParse(decision);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('decisions with invalid method fail validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          id: fc.uuid(),\r\n          timestamp: fc.nat(),\r\n          question: fc.string({ minLength: 1 }),\r\n          answer: fc.string({ minLength: 1 }),\r\n          confidence: fc.double({ min: 0, max: 1, noNaN: true }),\r\n          method: fc.string().filter(s => !['hybrid_agree', 'weighted_majority', 'critique_confident', 'weighted_default'].includes(s)),\r\n          votes: fc.array(voteArb, { minLength: 1, maxLength: 5 }),\r\n        }),\r\n        (decision) => {\r\n          const result = DecisionSchema.safeParse(decision);\r\n          expect(result.success).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('valid votes pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(voteArb, (vote) => {\r\n        const result = VoteSchema.safeParse(vote);\r\n        expect(result.success).toBe(true);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P5_PYRE_PRAETORIAN/PYRE_PRAETORIAN.property.test.ts":{"tests":[{"id":"199","name":"Property 11: Pyre Dance Termination terminates when all violations are resolved (rebirth)"},{"id":"200","name":"Property 11: Pyre Dance Termination terminates when max iterations reached (quarantine)"},{"id":"201","name":"Property 11: Pyre Dance Termination does not terminate while dancing with unresolved violations and iterations remaining"},{"id":"202","name":"Property 11: Pyre Dance Termination dance always terminates within maxIterations"},{"id":"203","name":"Property 12: Pyre Dance Response Chain createDanceState initializes with all violations unresolved"},{"id":"204","name":"Property 12: Pyre Dance Response Chain advanceDance increments iteration and resolves specified violations"},{"id":"205","name":"Property 12: Pyre Dance Response Chain resolving all violations leads to COMPLETED status"},{"id":"206","name":"P5 Schema Validation valid dance states pass schema validation"},{"id":"207","name":"P5 Schema Validation valid Phoenix certificates pass schema validation"}],"source":"/**\r\n * P5 PYRE PRAETORIAN - Property-Based Tests\r\n * \r\n * @port 5\r\n * @commander PYRE_PRAETORIAN\r\n * @provenance: design.md\r\n * Validates: Requirements 7.2, 7.3, 7.4, 11.1, 11.5\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport * as fc from 'fast-check';\r\nimport {\r\n  shouldTerminateDance,\r\n  getDanceOutcome,\r\n  createDanceState,\r\n  advanceDance,\r\n  PyreDanceStateSchema,\r\n  DanceResultSchema,\r\n  PhoenixImmunityCertificateSchema,\r\n} from './contracts/index.js';\r\n\r\n// --- Property 11: Pyre Dance Termination ---\r\n// Feature: legendary-commanders-gen88, Property 11: Pyre Dance Termination\r\n\r\ndescribe('Property 11: Pyre Dance Termination', () => {\r\n  \r\n  const violationArb = fc.record({\r\n    type: fc.constantFrom('THEATER', 'POLLUTION', 'AMNESIA', 'MUTATION_FAILURE'),\r\n    message: fc.string({ minLength: 1 }),\r\n    resolved: fc.boolean(),\r\n  });\r\n\r\n  const danceStateArb = fc.record({\r\n    artifact: fc.string({ minLength: 1 }),\r\n    iteration: fc.nat({ max: 20 }),\r\n    maxIterations: fc.integer({ min: 1, max: 20 }),\r\n    status: fc.constantFrom('DANCING', 'COMPLETED', 'QUARANTINED'),\r\n    violations: fc.array(violationArb, { minLength: 1, maxLength: 10 }),\r\n  });\r\n\r\n  it('terminates when all violations are resolved (rebirth)', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          iteration: fc.nat({ max: 5 }),\r\n          maxIterations: fc.integer({ min: 10, max: 20 }),\r\n          status: fc.constant('DANCING' as const),\r\n          violations: fc.array(\r\n            fc.record({\r\n              type: fc.constantFrom('THEATER', 'POLLUTION'),\r\n              message: fc.string({ minLength: 1 }),\r\n              resolved: fc.constant(true), // All resolved\r\n            }),\r\n            { minLength: 1, maxLength: 5 }\r\n          ),\r\n        }),\r\n        (state) => {\r\n          expect(shouldTerminateDance(state)).toBe(true);\r\n          expect(getDanceOutcome(state)).toBe('REBIRTH');\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('terminates when max iterations reached (quarantine)', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          iteration: fc.integer({ min: 10, max: 20 }),\r\n          maxIterations: fc.integer({ min: 1, max: 10 }),\r\n          status: fc.constant('DANCING' as const),\r\n          violations: fc.array(\r\n            fc.record({\r\n              type: fc.constantFrom('THEATER', 'POLLUTION'),\r\n              message: fc.string({ minLength: 1 }),\r\n              resolved: fc.constant(false), // Not resolved\r\n            }),\r\n            { minLength: 1, maxLength: 5 }\r\n          ),\r\n        }),\r\n        (state) => {\r\n          // iteration >= maxIterations means terminate\r\n          if (state.iteration >= state.maxIterations) {\r\n            expect(shouldTerminateDance(state)).toBe(true);\r\n            expect(getDanceOutcome(state)).toBe('QUARANTINE');\r\n          }\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('does not terminate while dancing with unresolved violations and iterations remaining', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          iteration: fc.integer({ min: 0, max: 4 }),\r\n          maxIterations: fc.constant(10),\r\n          status: fc.constant('DANCING' as const),\r\n          violations: fc.array(\r\n            fc.record({\r\n              type: fc.constantFrom('THEATER', 'POLLUTION'),\r\n              message: fc.string({ minLength: 1 }),\r\n              resolved: fc.constant(false),\r\n            }),\r\n            { minLength: 1, maxLength: 5 }\r\n          ),\r\n        }),\r\n        (state) => {\r\n          expect(shouldTerminateDance(state)).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('dance always terminates within maxIterations', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.string({ minLength: 1 }),\r\n        fc.array(\r\n          fc.record({\r\n            type: fc.constantFrom('THEATER', 'POLLUTION', 'AMNESIA'),\r\n            message: fc.string({ minLength: 1 }),\r\n          }),\r\n          { minLength: 1, maxLength: 5 }\r\n        ),\r\n        fc.integer({ min: 1, max: 10 }),\r\n        (artifact, violations, maxIter) => {\r\n          let state = createDanceState(artifact, violations);\r\n          state = { ...state, maxIterations: maxIter };\r\n          \r\n          let iterations = 0;\r\n          while (!shouldTerminateDance(state) && iterations < maxIter + 1) {\r\n            // Simulate no progress (worst case)\r\n            state = advanceDance(state, []);\r\n            iterations++;\r\n          }\r\n          \r\n          // Must terminate within maxIterations\r\n          expect(iterations).toBeLessThanOrEqual(maxIter);\r\n          expect(shouldTerminateDance(state)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Property 12: Pyre Dance Response Chain ---\r\n// Feature: legendary-commanders-gen88, Property 12: Pyre Dance Response Chain\r\n\r\ndescribe('Property 12: Pyre Dance Response Chain', () => {\r\n  \r\n  it('createDanceState initializes with all violations unresolved', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.string({ minLength: 1 }),\r\n        fc.array(\r\n          fc.record({\r\n            type: fc.constantFrom('THEATER', 'POLLUTION', 'AMNESIA'),\r\n            message: fc.string({ minLength: 1 }),\r\n          }),\r\n          { minLength: 1, maxLength: 10 }\r\n        ),\r\n        (artifact, violations) => {\r\n          const state = createDanceState(artifact, violations);\r\n          \r\n          expect(state.artifact).toBe(artifact);\r\n          expect(state.iteration).toBe(0);\r\n          expect(state.status).toBe('DANCING');\r\n          expect(state.violations.length).toBe(violations.length);\r\n          expect(state.violations.every(v => v.resolved === false)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('advanceDance increments iteration and resolves specified violations', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.string({ minLength: 1 }),\r\n        fc.array(\r\n          fc.record({\r\n            type: fc.constantFrom('THEATER', 'POLLUTION'),\r\n            message: fc.string({ minLength: 1 }),\r\n          }),\r\n          { minLength: 2, maxLength: 5 }\r\n        ),\r\n        (artifact, violations) => {\r\n          const state = createDanceState(artifact, violations);\r\n          \r\n          // Resolve first violation\r\n          const newState = advanceDance(state, [0]);\r\n          \r\n          expect(newState.iteration).toBe(1);\r\n          expect(newState.violations[0].resolved).toBe(true);\r\n          // Others remain unresolved\r\n          for (let i = 1; i < newState.violations.length; i++) {\r\n            expect(newState.violations[i].resolved).toBe(false);\r\n          }\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('resolving all violations leads to COMPLETED status', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.string({ minLength: 1 }),\r\n        fc.array(\r\n          fc.record({\r\n            type: fc.constantFrom('THEATER', 'POLLUTION'),\r\n            message: fc.string({ minLength: 1 }),\r\n          }),\r\n          { minLength: 1, maxLength: 5 }\r\n        ),\r\n        (artifact, violations) => {\r\n          let state = createDanceState(artifact, violations);\r\n          \r\n          // Resolve all violations in one step\r\n          const allIndices = violations.map((_, i) => i);\r\n          state = advanceDance(state, allIndices);\r\n          \r\n          expect(state.status).toBe('COMPLETED');\r\n          expect(state.violations.every(v => v.resolved)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Schema Validation ---\r\n\r\ndescribe('P5 Schema Validation', () => {\r\n  \r\n  it('valid dance states pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          artifact: fc.string({ minLength: 1 }),\r\n          iteration: fc.nat({ max: 100 }),\r\n          maxIterations: fc.integer({ min: 1, max: 100 }),\r\n          status: fc.constantFrom('DANCING', 'COMPLETED', 'QUARANTINED'),\r\n          violations: fc.array(\r\n            fc.record({\r\n              type: fc.string({ minLength: 1 }),\r\n              message: fc.string({ minLength: 1 }),\r\n              resolved: fc.boolean(),\r\n            }),\r\n            { minLength: 0, maxLength: 10 }\r\n          ),\r\n        }),\r\n        (state) => {\r\n          const result = PyreDanceStateSchema.safeParse(state);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('valid Phoenix certificates pass schema validation', () => {\r\n    // Generate valid hex string for hash\r\n    const hexCharArb = fc.constantFrom(...'0123456789abcdef'.split(''));\r\n    const hex64Arb = fc.array(hexCharArb, { minLength: 64, maxLength: 64 }).map(arr => arr.join(''));\r\n    \r\n    // Use integer timestamp to avoid date parsing issues\r\n    const isoDateArb = fc.integer({ min: 1577836800000, max: 1893456000000 }) // 2020-2030\r\n      .map(ts => new Date(ts).toISOString());\r\n    \r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          id: fc.uuid(),\r\n          artifact: fc.string({ minLength: 1 }),\r\n          issuedAt: isoDateArb,\r\n          attackVectorDefended: fc.string({ minLength: 1 }),\r\n          hash: hex64Arb.map(h => `sha256:${h}`),\r\n          generation: fc.nat(),\r\n        }),\r\n        (cert) => {\r\n          const result = PhoenixImmunityCertificateSchema.safeParse(cert);\r\n          expect(result.success).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P3_SPORE_STORM/SPORE_STORM.property.test.ts":{"tests":[{"id":"208","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant every injection has a valid UUID"},{"id":"209","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant every injection has a timestamp"},{"id":"210","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant injection sourcePort is always 3 (P3)"},{"id":"211","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant injection validates against schema"},{"id":"212","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant stigmergy event logs injection correctly"},{"id":"213","name":"P3 SPORE STORM - Property Tests Property 7: Injection Logging Invariant stigmergy event includes delivery result when provided"},{"id":"214","name":"P3 SPORE STORM - Property Tests Delivery Result Validation successful delivery has deliveredAt timestamp"},{"id":"215","name":"P3 SPORE STORM - Property Tests Delivery Result Validation failed delivery has error message"},{"id":"216","name":"P3 SPORE STORM - Property Tests Delivery Result Validation delivery result validates against schema"},{"id":"217","name":"P3 SPORE STORM - Property Tests Retry Logic new injection can be retried"},{"id":"218","name":"P3 SPORE STORM - Property Tests Retry Logic incrementRetry increases retry count"},{"id":"219","name":"P3 SPORE STORM - Property Tests Retry Logic cannot retry after max retries reached"},{"id":"220","name":"P3 SPORE STORM - Property Tests TTL / Expiration new injection is not expired"},{"id":"221","name":"P3 SPORE STORM - Property Tests TTL / Expiration injection with past timestamp + TTL is expired"},{"id":"222","name":"P3 SPORE STORM - Property Tests Cascade Config cascade config validates against schema"},{"id":"223","name":"P3 SPORE STORM - Property Tests Cascade Config cascade config requires at least one target"},{"id":"224","name":"P3 SPORE STORM - Property Tests Cascade Config cascade result validates against schema"}],"source":"/**\r\n * P3 SPORE STORM - Property Tests\r\n * \r\n * @port 3\r\n * @commander SPORE_STORM\r\n * @verb INJECT / DELIVER\r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 7 (Injection Logging Invariant)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  InjectionPayloadSchema,\r\n  DeliveryResultSchema,\r\n  CascadeConfigSchema,\r\n  CascadeResultSchema,\r\n  StigmergyInjectionEventSchema,\r\n  createInjection,\r\n  createDeliveryResult,\r\n  createStigmergyEvent,\r\n  canRetry,\r\n  incrementRetry,\r\n  isExpired,\r\n  type InjectionType,\r\n} from './contracts/index.js';\r\n\r\ndescribe('P3 SPORE STORM - Property Tests', () => {\r\n  // --- Property 7: Injection Logging Invariant ---\r\n  describe('Property 7: Injection Logging Invariant', () => {\r\n    it('every injection has a valid UUID', () => {\r\n      const types: InjectionType[] = ['FILE', 'EVENT', 'CASCADE', 'STIGMERGY', 'WEBHOOK'];\r\n      \r\n      for (const type of types) {\r\n        const injection = createInjection(type, 'target', { data: 'test' });\r\n        expect(injection.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\r\n      }\r\n    });\r\n\r\n    it('every injection has a timestamp', () => {\r\n      const before = Date.now();\r\n      const injection = createInjection('FILE', '/path/to/file', { content: 'data' });\r\n      const after = Date.now();\r\n      \r\n      expect(injection.timestamp).toBeGreaterThanOrEqual(before);\r\n      expect(injection.timestamp).toBeLessThanOrEqual(after);\r\n    });\r\n\r\n    it('injection sourcePort is always 3 (P3)', () => {\r\n      const injection = createInjection('EVENT', 'event-bus', {});\r\n      expect(injection.metadata.sourcePort).toBe(3);\r\n    });\r\n\r\n    it('injection validates against schema', () => {\r\n      const injection = createInjection('CASCADE', 'multi-target', { cascade: true }, {\r\n        priority: 'high',\r\n        correlationId: 'corr-123',\r\n        ttl: 30000,\r\n      });\r\n      \r\n      const result = InjectionPayloadSchema.safeParse(injection);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('stigmergy event logs injection correctly', () => {\r\n      const injection = createInjection('STIGMERGY', 'blackboard', { event: 'test' });\r\n      const event = createStigmergyEvent(injection);\r\n      \r\n      expect(event.sourcePort).toBe(3);\r\n      expect(event.eventType).toBe('INJECTION');\r\n      expect(event.payload).toEqual(injection);\r\n      \r\n      const result = StigmergyInjectionEventSchema.safeParse(event);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('stigmergy event includes delivery result when provided', () => {\r\n      const injection = createInjection('WEBHOOK', 'https://example.com', {});\r\n      const deliveryResult = createDeliveryResult(injection, true, { receivedBy: 'webhook-handler' });\r\n      const event = createStigmergyEvent(injection, deliveryResult);\r\n      \r\n      expect(event.result).toBeDefined();\r\n      expect(event.result?.success).toBe(true);\r\n    });\r\n  });\r\n\r\n  // --- Delivery Result Validation ---\r\n  describe('Delivery Result Validation', () => {\r\n    it('successful delivery has deliveredAt timestamp', () => {\r\n      const injection = createInjection('FILE', '/path', {});\r\n      const result = createDeliveryResult(injection, true, { receivedBy: 'file-system' });\r\n      \r\n      expect(result.success).toBe(true);\r\n      expect(result.deliveredAt).toBeDefined();\r\n      expect(result.acknowledgment).toBeDefined();\r\n      expect(result.acknowledgment?.receivedBy).toBe('file-system');\r\n    });\r\n\r\n    it('failed delivery has error message', () => {\r\n      const injection = createInjection('WEBHOOK', 'https://fail.com', {});\r\n      const result = createDeliveryResult(injection, false, { error: 'Connection refused', retryable: true });\r\n      \r\n      expect(result.success).toBe(false);\r\n      expect(result.error).toBe('Connection refused');\r\n      expect(result.retryable).toBe(true);\r\n      expect(result.deliveredAt).toBeUndefined();\r\n    });\r\n\r\n    it('delivery result validates against schema', () => {\r\n      const injection = createInjection('EVENT', 'bus', {});\r\n      const result = createDeliveryResult(injection, true);\r\n      \r\n      const parsed = DeliveryResultSchema.safeParse(result);\r\n      expect(parsed.success).toBe(true);\r\n    });\r\n  });\r\n\r\n  // --- Retry Logic ---\r\n  describe('Retry Logic', () => {\r\n    it('new injection can be retried', () => {\r\n      const injection = createInjection('WEBHOOK', 'target', {});\r\n      expect(canRetry(injection)).toBe(true);\r\n      expect(injection.metadata.retryCount).toBe(0);\r\n      expect(injection.metadata.maxRetries).toBe(3);\r\n    });\r\n\r\n    it('incrementRetry increases retry count', () => {\r\n      let injection = createInjection('WEBHOOK', 'target', {});\r\n      expect(injection.metadata.retryCount).toBe(0);\r\n      \r\n      injection = incrementRetry(injection);\r\n      expect(injection.metadata.retryCount).toBe(1);\r\n      \r\n      injection = incrementRetry(injection);\r\n      expect(injection.metadata.retryCount).toBe(2);\r\n    });\r\n\r\n    it('cannot retry after max retries reached', () => {\r\n      let injection = createInjection('WEBHOOK', 'target', {});\r\n      \r\n      injection = incrementRetry(injection);\r\n      injection = incrementRetry(injection);\r\n      injection = incrementRetry(injection);\r\n      \r\n      expect(injection.metadata.retryCount).toBe(3);\r\n      expect(canRetry(injection)).toBe(false);\r\n    });\r\n  });\r\n\r\n  // --- TTL / Expiration ---\r\n  describe('TTL / Expiration', () => {\r\n    it('new injection is not expired', () => {\r\n      const injection = createInjection('FILE', 'target', {});\r\n      expect(isExpired(injection)).toBe(false);\r\n    });\r\n\r\n    it('injection with past timestamp + TTL is expired', () => {\r\n      const injection = createInjection('FILE', 'target', {}, { ttl: 1000 });\r\n      // Manually set timestamp to past\r\n      const expiredInjection = {\r\n        ...injection,\r\n        timestamp: Date.now() - 2000, // 2 seconds ago\r\n      };\r\n      \r\n      expect(isExpired(expiredInjection)).toBe(true);\r\n    });\r\n  });\r\n\r\n  // --- Cascade Config ---\r\n  describe('Cascade Config', () => {\r\n    it('cascade config validates against schema', () => {\r\n      const config = {\r\n        targets: ['target1', 'target2', 'target3'],\r\n        strategy: 'parallel' as const,\r\n        failureMode: 'best_effort' as const,\r\n        timeout: 15000,\r\n      };\r\n      \r\n      const result = CascadeConfigSchema.safeParse(config);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('cascade config requires at least one target', () => {\r\n      const config = {\r\n        targets: [],\r\n        strategy: 'sequential' as const,\r\n        failureMode: 'fail_fast' as const,\r\n      };\r\n      \r\n      const result = CascadeConfigSchema.safeParse(config);\r\n      expect(result.success).toBe(false);\r\n    });\r\n\r\n    it('cascade result validates against schema', () => {\r\n      const injection = createInjection('CASCADE', 'multi', {});\r\n      const cascadeResult = {\r\n        id: crypto.randomUUID(),\r\n        config: {\r\n          targets: ['t1', 't2'],\r\n          strategy: 'fanout' as const,\r\n          failureMode: 'all_or_nothing' as const,\r\n          timeout: 30000,\r\n        },\r\n        results: [\r\n          createDeliveryResult(injection, true),\r\n          createDeliveryResult(injection, false, { error: 'timeout' }),\r\n        ],\r\n        successCount: 1,\r\n        failureCount: 1,\r\n        totalDuration: 500,\r\n      };\r\n      \r\n      const result = CascadeResultSchema.safeParse(cascadeResult);\r\n      expect(result.success).toBe(true);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P2_MIRROR_MAGUS/MIRROR_MAGUS.property.test.ts":{"tests":[{"id":"225","name":"P2 MIRROR MAGUS - Property Tests Property 5: Schema Transformation Round-Trip invertible transformations round-trip correctly"},{"id":"226","name":"P2 MIRROR MAGUS - Property Tests Property 5: Schema Transformation Round-Trip non-invertible transformations fail round-trip"},{"id":"227","name":"P2 MIRROR MAGUS - Property Tests Property 5: Schema Transformation Round-Trip transformation records validate against schema"},{"id":"228","name":"P2 MIRROR MAGUS - Property Tests Property 5: Schema Transformation Round-Trip transformation has valid UUID"},{"id":"229","name":"P2 MIRROR MAGUS - Property Tests Property 5: Schema Transformation Round-Trip transformation has timestamp"},{"id":"230","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing filter state initializes correctly"},{"id":"231","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing first value passes through unchanged"},{"id":"232","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing smoothing factor is bounded (0, 1)"},{"id":"233","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing exponential smoothing interpolates between values"},{"id":"234","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing filter reduces noise (smoothed values closer to mean)"},{"id":"235","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing filter config validates against schema"},{"id":"236","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing filter state validates against schema"},{"id":"237","name":"P2 MIRROR MAGUS - Property Tests Property 6: One Euro Filter Smoothing zero time delta returns previous value"},{"id":"238","name":"P2 MIRROR MAGUS - Property Tests Shape Result Validation successful shape result validates"},{"id":"239","name":"P2 MIRROR MAGUS - Property Tests Shape Result Validation failed shape result validates"}],"source":"/**\r\n * P2 MIRROR MAGUS - Property Tests\r\n * \r\n * @port 2\r\n * @commander MIRROR_MAGUS\r\n * @verb SHAPE / TRANSFORM\r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 5 (Schema Transformation Round-Trip), Property 6 (One Euro Filter Smoothing)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  TransformationSchema,\r\n  OneEuroFilterConfigSchema,\r\n  OneEuroFilterStateSchema,\r\n  ShapeResultSchema,\r\n  createTransformation,\r\n  createFilterState,\r\n  applyOneEuroFilter,\r\n  smoothingFactor,\r\n  exponentialSmoothing,\r\n  isRoundTripValid,\r\n  type OneEuroFilterConfig,\r\n  type OneEuroFilterState,\r\n} from './contracts/index.js';\r\n\r\ndescribe('P2 MIRROR MAGUS - Property Tests', () => {\r\n  // --- Property 5: Schema Transformation Round-Trip ---\r\n  describe('Property 5: Schema Transformation Round-Trip', () => {\r\n    it('invertible transformations round-trip correctly', () => {\r\n      // Simple invertible transform: multiply by 2\r\n      const transform = (x: number) => x * 2;\r\n      const inverse = (x: number) => x / 2;\r\n      const equals = (a: number, b: number) => Math.abs(a - b) < 0.0001;\r\n      \r\n      expect(isRoundTripValid(5, transform, inverse, equals)).toBe(true);\r\n      expect(isRoundTripValid(0, transform, inverse, equals)).toBe(true);\r\n      expect(isRoundTripValid(-10, transform, inverse, equals)).toBe(true);\r\n    });\r\n\r\n    it('non-invertible transformations fail round-trip', () => {\r\n      // Non-invertible: floor function\r\n      const transform = (x: number) => Math.floor(x);\r\n      const inverse = (x: number) => x; // Can't truly invert floor\r\n      const equals = (a: number, b: number) => a === b;\r\n      \r\n      expect(isRoundTripValid(5.7, transform, inverse, equals)).toBe(false);\r\n    });\r\n\r\n    it('transformation records validate against schema', () => {\r\n      const t = createTransformation('NORMALIZE', { raw: 100 }, { normalized: 0.5 }, true, { scale: 200 });\r\n      \r\n      const result = TransformationSchema.safeParse(t);\r\n      expect(result.success).toBe(true);\r\n      expect(t.invertible).toBe(true);\r\n    });\r\n\r\n    it('transformation has valid UUID', () => {\r\n      const t = createTransformation('SCHEMA_MORPH', {}, {}, false);\r\n      expect(t.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\r\n    });\r\n\r\n    it('transformation has timestamp', () => {\r\n      const before = Date.now();\r\n      const t = createTransformation('AGGREGATE', [], {}, false);\r\n      const after = Date.now();\r\n      \r\n      expect(t.timestamp).toBeGreaterThanOrEqual(before);\r\n      expect(t.timestamp).toBeLessThanOrEqual(after);\r\n    });\r\n  });\r\n\r\n  // --- Property 6: One Euro Filter Smoothing ---\r\n  describe('Property 6: One Euro Filter Smoothing', () => {\r\n    const defaultConfig: OneEuroFilterConfig = {\r\n      minCutoff: 1.0,\r\n      beta: 0.007,\r\n      dCutoff: 1.0,\r\n      frequency: 120,\r\n    };\r\n\r\n    it('filter state initializes correctly', () => {\r\n      const state = createFilterState();\r\n      expect(state.initialized).toBe(false);\r\n      expect(state.x).toBe(0);\r\n      expect(state.dx).toBe(0);\r\n    });\r\n\r\n    it('first value passes through unchanged', () => {\r\n      const state = createFilterState();\r\n      const [filtered, newState] = applyOneEuroFilter(100, 0, state, defaultConfig);\r\n      \r\n      expect(filtered).toBe(100);\r\n      expect(newState.initialized).toBe(true);\r\n      expect(newState.x).toBe(100);\r\n    });\r\n\r\n    it('smoothing factor is bounded (0, 1)', () => {\r\n      // Various te and cutoff values\r\n      const testCases = [\r\n        { te: 0.001, cutoff: 1 },\r\n        { te: 0.01, cutoff: 10 },\r\n        { te: 0.1, cutoff: 100 },\r\n      ];\r\n      \r\n      for (const { te, cutoff } of testCases) {\r\n        const sf = smoothingFactor(te, cutoff);\r\n        expect(sf).toBeGreaterThan(0);\r\n        expect(sf).toBeLessThan(1);\r\n      }\r\n    });\r\n\r\n    it('exponential smoothing interpolates between values', () => {\r\n      // a=0 → returns xPrev\r\n      expect(exponentialSmoothing(0, 100, 50)).toBe(50);\r\n      // a=1 → returns x\r\n      expect(exponentialSmoothing(1, 100, 50)).toBe(100);\r\n      // a=0.5 → returns midpoint\r\n      expect(exponentialSmoothing(0.5, 100, 50)).toBe(75);\r\n    });\r\n\r\n    it('filter reduces noise (smoothed values closer to mean)', () => {\r\n      let state = createFilterState();\r\n      const noisySignal = [100, 105, 95, 102, 98, 103, 97, 101, 99, 100];\r\n      const filtered: number[] = [];\r\n      \r\n      let t = 0;\r\n      for (const value of noisySignal) {\r\n        const [f, newState] = applyOneEuroFilter(value, t, state, defaultConfig);\r\n        filtered.push(f);\r\n        state = newState;\r\n        t += 1 / defaultConfig.frequency;\r\n      }\r\n      \r\n      // Calculate variance of original vs filtered\r\n      const mean = 100;\r\n      const originalVariance = noisySignal.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / noisySignal.length;\r\n      const filteredVariance = filtered.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / filtered.length;\r\n      \r\n      // Filtered should have lower variance (smoother)\r\n      expect(filteredVariance).toBeLessThan(originalVariance);\r\n    });\r\n\r\n    it('filter config validates against schema', () => {\r\n      const result = OneEuroFilterConfigSchema.safeParse(defaultConfig);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('filter state validates against schema', () => {\r\n      const state: OneEuroFilterState = {\r\n        x: 50,\r\n        dx: 0.1,\r\n        lastTime: 1000,\r\n        initialized: true,\r\n      };\r\n      \r\n      const result = OneEuroFilterStateSchema.safeParse(state);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('zero time delta returns previous value', () => {\r\n      let state = createFilterState();\r\n      const [, newState] = applyOneEuroFilter(100, 0, state, defaultConfig);\r\n      \r\n      // Same timestamp should return previous value\r\n      const [filtered, _] = applyOneEuroFilter(200, 0, newState, defaultConfig);\r\n      expect(filtered).toBe(100);\r\n    });\r\n  });\r\n\r\n  // --- Shape Result Validation ---\r\n  describe('Shape Result Validation', () => {\r\n    it('successful shape result validates', () => {\r\n      const result = {\r\n        success: true,\r\n        transformation: createTransformation('NORMALIZE', 100, 0.5, true),\r\n        canInvert: true,\r\n      };\r\n      \r\n      const parsed = ShapeResultSchema.safeParse(result);\r\n      expect(parsed.success).toBe(true);\r\n    });\r\n\r\n    it('failed shape result validates', () => {\r\n      const result = {\r\n        success: false,\r\n        error: 'Invalid input schema',\r\n        canInvert: false,\r\n      };\r\n      \r\n      const parsed = ShapeResultSchema.safeParse(result);\r\n      expect(parsed.success).toBe(true);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/contracts/receipt-hash.test.ts":{"tests":[{"id":"240","name":"Property 17: Receipt Hash Integrity Hash Computation same content produces same hash"},{"id":"241","name":"Property 17: Receipt Hash Integrity Hash Computation different content produces different hash"},{"id":"242","name":"Property 17: Receipt Hash Integrity Hash Computation hash has correct format"},{"id":"243","name":"Property 17: Receipt Hash Integrity Receipt Creation creates valid receipt with hash"},{"id":"244","name":"Property 17: Receipt Hash Integrity Receipt Creation receipt validates against schema"},{"id":"245","name":"Property 17: Receipt Hash Integrity Receipt Creation receipt has valid UUID"},{"id":"246","name":"Property 17: Receipt Hash Integrity Hash Verification valid receipt passes verification"},{"id":"247","name":"Property 17: Receipt Hash Integrity Hash Verification tampered receipt fails verification"},{"id":"248","name":"Property 17: Receipt Hash Integrity Hash Verification tampered artifact fails verification"},{"id":"249","name":"Property 17: Receipt Hash Integrity Silver Standard Validation valid receipt passes Silver Standard"},{"id":"250","name":"Property 17: Receipt Hash Integrity Silver Standard Validation low mutation score fails"},{"id":"251","name":"Property 17: Receipt Hash Integrity Silver Standard Validation theater score (>98.99%) fails"},{"id":"252","name":"Property 17: Receipt Hash Integrity Silver Standard Validation missing property tests fails"},{"id":"253","name":"Property 17: Receipt Hash Integrity Silver Standard Validation missing Zod contracts fails"},{"id":"254","name":"Property 17: Receipt Hash Integrity Silver Standard Validation missing provenance headers fails"}],"source":"/**\r\n * Receipt Hash Integrity - Property Tests\r\n * \r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 17 (Receipt Hash Integrity)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  PromotionReceiptSchema,\r\n  computeHashSync,\r\n  createReceiptContent,\r\n  verifyReceiptHash,\r\n  createPromotionReceipt,\r\n  validateSilverStandard,\r\n} from './receipt-hash.js';\r\n\r\ndescribe('Property 17: Receipt Hash Integrity', () => {\r\n  // --- Hash Computation ---\r\n  describe('Hash Computation', () => {\r\n    it('same content produces same hash', () => {\r\n      const content = 'test content';\r\n      const hash1 = computeHashSync(content);\r\n      const hash2 = computeHashSync(content);\r\n      expect(hash1).toBe(hash2);\r\n    });\r\n\r\n    it('different content produces different hash', () => {\r\n      const hash1 = computeHashSync('content A');\r\n      const hash2 = computeHashSync('content B');\r\n      expect(hash1).not.toBe(hash2);\r\n    });\r\n\r\n    it('hash has correct format', () => {\r\n      const hash = computeHashSync('test');\r\n      expect(hash).toMatch(/^sha256:[a-f0-9]{64}$/);\r\n    });\r\n  });\r\n\r\n  // --- Receipt Creation ---\r\n  describe('Receipt Creation', () => {\r\n    it('creates valid receipt with hash', () => {\r\n      const receipt = createPromotionReceipt(\r\n        'P4_RED_REGNANT/contracts/index.ts',\r\n        'bronze',\r\n        'silver',\r\n        88.5,\r\n        {\r\n          propertyTestsPassed: true,\r\n          zodContractsPresent: true,\r\n          provenanceHeadersPresent: true,\r\n        }\r\n      );\r\n      \r\n      expect(receipt.hash).toMatch(/^sha256:[a-f0-9]{64}$/);\r\n      expect(receipt.artifact).toBe('P4_RED_REGNANT/contracts/index.ts');\r\n      expect(receipt.mutationScore).toBe(88.5);\r\n    });\r\n\r\n    it('receipt validates against schema', () => {\r\n      const receipt = createPromotionReceipt(\r\n        'test-artifact',\r\n        'bronze',\r\n        'silver',\r\n        90,\r\n        {\r\n          propertyTestsPassed: true,\r\n          zodContractsPresent: true,\r\n          provenanceHeadersPresent: true,\r\n        }\r\n      );\r\n      \r\n      const result = PromotionReceiptSchema.safeParse(receipt);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('receipt has valid UUID', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 85, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      expect(receipt.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\r\n    });\r\n  });\r\n\r\n  // --- Hash Verification ---\r\n  describe('Hash Verification', () => {\r\n    it('valid receipt passes verification', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      expect(verifyReceiptHash(receipt)).toBe(true);\r\n    });\r\n\r\n    it('tampered receipt fails verification', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      // Tamper with mutation score\r\n      const tampered = { ...receipt, mutationScore: 99 };\r\n      expect(verifyReceiptHash(tampered)).toBe(false);\r\n    });\r\n\r\n    it('tampered artifact fails verification', () => {\r\n      const receipt = createPromotionReceipt('original', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      const tampered = { ...receipt, artifact: 'tampered' };\r\n      expect(verifyReceiptHash(tampered)).toBe(false);\r\n    });\r\n  });\r\n\r\n  // --- Silver Standard Validation ---\r\n  describe('Silver Standard Validation', () => {\r\n    it('valid receipt passes Silver Standard', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      const result = validateSilverStandard(receipt);\r\n      expect(result.valid).toBe(true);\r\n      expect(result.errors).toHaveLength(0);\r\n    });\r\n\r\n    it('low mutation score fails', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 79, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      // Force schema to accept for testing\r\n      const result = validateSilverStandard({ ...receipt, mutationScore: 79 } as any);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('below minimum'))).toBe(true);\r\n    });\r\n\r\n    it('theater score (>98.99%) fails', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 99, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      const result = validateSilverStandard({ ...receipt, mutationScore: 99 } as any);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Theater'))).toBe(true);\r\n    });\r\n\r\n    it('missing property tests fails', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: false,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      const result = validateSilverStandard(receipt);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Property tests'))).toBe(true);\r\n    });\r\n\r\n    it('missing Zod contracts fails', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: false,\r\n        provenanceHeadersPresent: true,\r\n      });\r\n      \r\n      const result = validateSilverStandard(receipt);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Zod contracts'))).toBe(true);\r\n    });\r\n\r\n    it('missing provenance headers fails', () => {\r\n      const receipt = createPromotionReceipt('test', 'bronze', 'silver', 88, {\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: false,\r\n      });\r\n      \r\n      const result = validateSilverStandard(receipt);\r\n      expect(result.valid).toBe(false);\r\n      expect(result.errors.some(e => e.includes('Provenance'))).toBe(true);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P0_LIDLESS_LEGION/LIDLESS_LEGION.property.test.ts":{"tests":[{"id":"255","name":"P0 LIDLESS LEGION - Property Tests Property 2: Observation Logging Invariant every observation has a valid UUID"},{"id":"256","name":"P0 LIDLESS LEGION - Property Tests Property 2: Observation Logging Invariant every observation has a timestamp"},{"id":"257","name":"P0 LIDLESS LEGION - Property Tests Property 2: Observation Logging Invariant observations validate against schema"},{"id":"258","name":"P0 LIDLESS LEGION - Property Tests Property 2: Observation Logging Invariant observation batches validate against schema"},{"id":"259","name":"P0 LIDLESS LEGION - Property Tests Property 2: Observation Logging Invariant confidence is bounded [0, 1]"},{"id":"260","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns OBSERVE is an allowed verb"},{"id":"261","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns SENSE is an allowed verb"},{"id":"262","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns SHAPE is forbidden for P0"},{"id":"263","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns STORE is forbidden for P0"},{"id":"264","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns DECIDE is forbidden for P0"},{"id":"265","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns INJECT is forbidden for P0"},{"id":"266","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns DISRUPT is forbidden for P0"},{"id":"267","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns IMMUNIZE is forbidden for P0"},{"id":"268","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns BRIDGE is forbidden for P0"},{"id":"269","name":"P0 LIDLESS LEGION - Property Tests Property 3: Separation of Concerns ASSIMILATE is forbidden for P0"},{"id":"270","name":"P0 LIDLESS LEGION - Property Tests Observation Filtering filters by source"},{"id":"271","name":"P0 LIDLESS LEGION - Property Tests Observation Filtering filters by minimum confidence"},{"id":"272","name":"P0 LIDLESS LEGION - Property Tests Observation Filtering filters by tags (all must match)"},{"id":"273","name":"P0 LIDLESS LEGION - Property Tests Observation Filtering respects limit"},{"id":"274","name":"P0 LIDLESS LEGION - Property Tests Observation Filtering filter schema validates"}],"source":"/**\r\n * P0 LIDLESS LEGION - Property Tests\r\n * \r\n * @port 0\r\n * @commander LIDLESS_LEGION\r\n * @verb OBSERVE / SENSE\r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 2 (Observation Logging), Property 3 (Separation of Concerns)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  ObservationSchema,\r\n  ObservationBatchSchema,\r\n  ObservationFilterSchema,\r\n  createObservation,\r\n  filterObservations,\r\n  batchObservations,\r\n  isAllowedVerb,\r\n  isForbiddenVerb,\r\n  type Observation,\r\n  type ObservationSource,\r\n} from './contracts/index.js';\r\n\r\ndescribe('P0 LIDLESS LEGION - Property Tests', () => {\r\n  // --- Property 2: Observation Logging Invariant ---\r\n  describe('Property 2: Observation Logging Invariant', () => {\r\n    it('every observation has a valid UUID', () => {\r\n      const sources: ObservationSource[] = ['TAVILY', 'PERPLEXITY', 'OSINT', 'MEDIAPIPE', 'WEBCAM', 'FILE_SYSTEM', 'STIGMERGY'];\r\n      \r\n      for (const source of sources) {\r\n        const obs = createObservation(source, { test: 'data' });\r\n        expect(obs.id).toMatch(/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i);\r\n      }\r\n    });\r\n\r\n    it('every observation has a timestamp', () => {\r\n      const before = Date.now();\r\n      const obs = createObservation('TAVILY', { query: 'test' });\r\n      const after = Date.now();\r\n      \r\n      expect(obs.timestamp).toBeGreaterThanOrEqual(before);\r\n      expect(obs.timestamp).toBeLessThanOrEqual(after);\r\n    });\r\n\r\n    it('observations validate against schema', () => {\r\n      const obs = createObservation('PERPLEXITY', { result: 'data' }, {\r\n        query: 'test query',\r\n        confidence: 0.95,\r\n        latencyMs: 150,\r\n        tags: ['search', 'grounding'],\r\n      });\r\n      \r\n      const result = ObservationSchema.safeParse(obs);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('observation batches validate against schema', () => {\r\n      const obs1 = createObservation('TAVILY', { a: 1 });\r\n      const obs2 = createObservation('OSINT', { b: 2 });\r\n      const batch = batchObservations([obs1, obs2], 'correlation-123');\r\n      \r\n      const result = ObservationBatchSchema.safeParse(batch);\r\n      expect(result.success).toBe(true);\r\n      expect(batch.observations).toHaveLength(2);\r\n    });\r\n\r\n    it('confidence is bounded [0, 1]', () => {\r\n      const obs = createObservation('MEDIAPIPE', {}, { confidence: 0.5 });\r\n      expect(obs.confidence).toBeGreaterThanOrEqual(0);\r\n      expect(obs.confidence).toBeLessThanOrEqual(1);\r\n      \r\n      // Schema rejects out-of-bounds\r\n      const invalid = { ...obs, confidence: 1.5 };\r\n      const result = ObservationSchema.safeParse(invalid);\r\n      expect(result.success).toBe(false);\r\n    });\r\n  });\r\n\r\n  // --- Property 3: Separation of Concerns (P0) ---\r\n  describe('Property 3: Separation of Concerns', () => {\r\n    it('OBSERVE is an allowed verb', () => {\r\n      expect(isAllowedVerb('OBSERVE')).toBe(true);\r\n    });\r\n\r\n    it('SENSE is an allowed verb', () => {\r\n      expect(isAllowedVerb('SENSE')).toBe(true);\r\n    });\r\n\r\n    it('SHAPE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('SHAPE')).toBe(true);\r\n      expect(isAllowedVerb('SHAPE')).toBe(false);\r\n    });\r\n\r\n    it('STORE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('STORE')).toBe(true);\r\n      expect(isAllowedVerb('STORE')).toBe(false);\r\n    });\r\n\r\n    it('DECIDE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('DECIDE')).toBe(true);\r\n      expect(isAllowedVerb('DECIDE')).toBe(false);\r\n    });\r\n\r\n    it('INJECT is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('INJECT')).toBe(true);\r\n      expect(isAllowedVerb('INJECT')).toBe(false);\r\n    });\r\n\r\n    it('DISRUPT is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('DISRUPT')).toBe(true);\r\n      expect(isAllowedVerb('DISRUPT')).toBe(false);\r\n    });\r\n\r\n    it('IMMUNIZE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('IMMUNIZE')).toBe(true);\r\n      expect(isAllowedVerb('IMMUNIZE')).toBe(false);\r\n    });\r\n\r\n    it('BRIDGE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('BRIDGE')).toBe(true);\r\n      expect(isAllowedVerb('BRIDGE')).toBe(false);\r\n    });\r\n\r\n    it('ASSIMILATE is forbidden for P0', () => {\r\n      expect(isForbiddenVerb('ASSIMILATE')).toBe(true);\r\n      expect(isAllowedVerb('ASSIMILATE')).toBe(false);\r\n    });\r\n  });\r\n\r\n  // --- Observation Filtering ---\r\n  describe('Observation Filtering', () => {\r\n    const observations: Observation[] = [\r\n      createObservation('TAVILY', { a: 1 }, { confidence: 0.9, tags: ['search'] }),\r\n      createObservation('PERPLEXITY', { b: 2 }, { confidence: 0.8, tags: ['search', 'ai'] }),\r\n      createObservation('OSINT', { c: 3 }, { confidence: 0.7, tags: ['intel'] }),\r\n      createObservation('MEDIAPIPE', { d: 4 }, { confidence: 0.95, tags: ['gesture'] }),\r\n    ];\r\n\r\n    it('filters by source', () => {\r\n      const result = filterObservations(observations, { sources: ['TAVILY', 'PERPLEXITY'], limit: 100 });\r\n      expect(result).toHaveLength(2);\r\n      expect(result.every(o => o.source === 'TAVILY' || o.source === 'PERPLEXITY')).toBe(true);\r\n    });\r\n\r\n    it('filters by minimum confidence', () => {\r\n      const result = filterObservations(observations, { minConfidence: 0.85, limit: 100 });\r\n      expect(result).toHaveLength(2);\r\n      expect(result.every(o => o.confidence >= 0.85)).toBe(true);\r\n    });\r\n\r\n    it('filters by tags (all must match)', () => {\r\n      const result = filterObservations(observations, { tags: ['search'], limit: 100 });\r\n      expect(result).toHaveLength(2);\r\n      \r\n      const result2 = filterObservations(observations, { tags: ['search', 'ai'], limit: 100 });\r\n      expect(result2).toHaveLength(1);\r\n    });\r\n\r\n    it('respects limit', () => {\r\n      const result = filterObservations(observations, { limit: 2 });\r\n      expect(result).toHaveLength(2);\r\n    });\r\n\r\n    it('filter schema validates', () => {\r\n      const filter = { sources: ['TAVILY'], minConfidence: 0.5, limit: 50 };\r\n      const result = ObservationFilterSchema.safeParse(filter);\r\n      expect(result.success).toBe(true);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/contracts/verb-enforcement.test.ts":{"tests":[{"id":"275","name":"Property 14: Verb Enforcement Verb Allowance P0 only allows OBSERVE and SENSE"},{"id":"276","name":"Property 14: Verb Enforcement Verb Allowance P1 only allows BRIDGE and FUSE"},{"id":"277","name":"Property 14: Verb Enforcement Verb Allowance P2 only allows SHAPE and TRANSFORM"},{"id":"278","name":"Property 14: Verb Enforcement Verb Allowance P3 only allows INJECT and DELIVER"},{"id":"279","name":"Property 14: Verb Enforcement Verb Allowance P4 only allows DISRUPT, SING, SCREAM"},{"id":"280","name":"Property 14: Verb Enforcement Verb Allowance P5 only allows DANCE, DIE, IMMUNIZE"},{"id":"281","name":"Property 14: Verb Enforcement Verb Allowance P6 only allows ASSIMILATE and STORE"},{"id":"282","name":"Property 14: Verb Enforcement Verb Allowance P7 only allows DECIDE and NAVIGATE"},{"id":"283","name":"Property 14: Verb Enforcement Verb Violation creates valid violation record"},{"id":"284","name":"Property 14: Verb Enforcement Verb Violation violation validates against schema"},{"id":"285","name":"Property 14: Verb Enforcement HIVE/8 Anti-Diagonal Pairings all HIVE pairs sum to 7"},{"id":"286","name":"Property 14: Verb Enforcement HIVE/8 Anti-Diagonal Pairings isValidHivePair returns true for valid pairs"},{"id":"287","name":"Property 14: Verb Enforcement HIVE/8 Anti-Diagonal Pairings isValidHivePair returns false for invalid pairs"},{"id":"288","name":"Property 14: Verb Enforcement HIVE/8 Anti-Diagonal Pairings getHivePhase returns correct phase"},{"id":"289","name":"Property 14: Verb Enforcement HIVE/8 Anti-Diagonal Pairings getHivePhase returns null for invalid pairs"},{"id":"290","name":"Property 14: Verb Enforcement PREY/8 Serpentine Pairings getPreyPhase returns correct phase"},{"id":"291","name":"Property 14: Verb Enforcement PREY/8 Serpentine Pairings getPreyPhase returns null for non-PREY pairs"},{"id":"292","name":"Property 14: Verb Enforcement All Ports Have Verbs every port has at least one verb"},{"id":"293","name":"Property 14: Verb Enforcement All Ports Have Verbs no verb is shared between ports"}],"source":"/**\r\n * Cross-Commander Verb Enforcement - Property Tests\r\n * \r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 14 (Verb Enforcement)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  COMMANDER_VERBS,\r\n  HIVE_PAIRINGS,\r\n  PREY_PAIRINGS,\r\n  isVerbAllowed,\r\n  getAllowedVerbs,\r\n  createVerbViolation,\r\n  isValidHivePair,\r\n  getHivePhase,\r\n  getPreyPhase,\r\n  VerbViolationSchema,\r\n  type Port,\r\n} from './verb-enforcement.js';\r\n\r\ndescribe('Property 14: Verb Enforcement', () => {\r\n  // --- Verb Allowance ---\r\n  describe('Verb Allowance', () => {\r\n    it('P0 only allows OBSERVE and SENSE', () => {\r\n      expect(isVerbAllowed(0, 'OBSERVE')).toBe(true);\r\n      expect(isVerbAllowed(0, 'SENSE')).toBe(true);\r\n      expect(isVerbAllowed(0, 'SHAPE')).toBe(false);\r\n      expect(isVerbAllowed(0, 'DECIDE')).toBe(false);\r\n    });\r\n\r\n    it('P1 only allows BRIDGE and FUSE', () => {\r\n      expect(isVerbAllowed(1, 'BRIDGE')).toBe(true);\r\n      expect(isVerbAllowed(1, 'FUSE')).toBe(true);\r\n      expect(isVerbAllowed(1, 'INJECT')).toBe(false);\r\n    });\r\n\r\n    it('P2 only allows SHAPE and TRANSFORM', () => {\r\n      expect(isVerbAllowed(2, 'SHAPE')).toBe(true);\r\n      expect(isVerbAllowed(2, 'TRANSFORM')).toBe(true);\r\n      expect(isVerbAllowed(2, 'OBSERVE')).toBe(false);\r\n    });\r\n\r\n    it('P3 only allows INJECT and DELIVER', () => {\r\n      expect(isVerbAllowed(3, 'INJECT')).toBe(true);\r\n      expect(isVerbAllowed(3, 'DELIVER')).toBe(true);\r\n      expect(isVerbAllowed(3, 'STORE')).toBe(false);\r\n    });\r\n\r\n    it('P4 only allows DISRUPT, SING, SCREAM', () => {\r\n      expect(isVerbAllowed(4, 'DISRUPT')).toBe(true);\r\n      expect(isVerbAllowed(4, 'SING')).toBe(true);\r\n      expect(isVerbAllowed(4, 'SCREAM')).toBe(true);\r\n      expect(isVerbAllowed(4, 'DANCE')).toBe(false);\r\n    });\r\n\r\n    it('P5 only allows DANCE, DIE, IMMUNIZE', () => {\r\n      expect(isVerbAllowed(5, 'DANCE')).toBe(true);\r\n      expect(isVerbAllowed(5, 'DIE')).toBe(true);\r\n      expect(isVerbAllowed(5, 'IMMUNIZE')).toBe(true);\r\n      expect(isVerbAllowed(5, 'SCREAM')).toBe(false);\r\n    });\r\n\r\n    it('P6 only allows ASSIMILATE and STORE', () => {\r\n      expect(isVerbAllowed(6, 'ASSIMILATE')).toBe(true);\r\n      expect(isVerbAllowed(6, 'STORE')).toBe(true);\r\n      expect(isVerbAllowed(6, 'NAVIGATE')).toBe(false);\r\n    });\r\n\r\n    it('P7 only allows DECIDE and NAVIGATE', () => {\r\n      expect(isVerbAllowed(7, 'DECIDE')).toBe(true);\r\n      expect(isVerbAllowed(7, 'NAVIGATE')).toBe(true);\r\n      expect(isVerbAllowed(7, 'OBSERVE')).toBe(false);\r\n    });\r\n  });\r\n\r\n  // --- Verb Violation ---\r\n  describe('Verb Violation', () => {\r\n    it('creates valid violation record', () => {\r\n      const violation = createVerbViolation(0, 'SHAPE');\r\n      \r\n      expect(violation.sourcePort).toBe(0);\r\n      expect(violation.attemptedVerb).toBe('SHAPE');\r\n      expect(violation.allowedVerbs).toContain('OBSERVE');\r\n      expect(violation.allowedVerbs).toContain('SENSE');\r\n      expect(violation.message).toContain('Port 0');\r\n    });\r\n\r\n    it('violation validates against schema', () => {\r\n      const violation = createVerbViolation(3, 'DECIDE');\r\n      const result = VerbViolationSchema.safeParse(violation);\r\n      expect(result.success).toBe(true);\r\n    });\r\n  });\r\n\r\n  // --- HIVE/8 Anti-Diagonal ---\r\n  describe('HIVE/8 Anti-Diagonal Pairings', () => {\r\n    it('all HIVE pairs sum to 7', () => {\r\n      for (const [phase, [a, b]] of Object.entries(HIVE_PAIRINGS)) {\r\n        expect(a + b).toBe(7);\r\n      }\r\n    });\r\n\r\n    it('isValidHivePair returns true for valid pairs', () => {\r\n      expect(isValidHivePair(0, 7)).toBe(true);\r\n      expect(isValidHivePair(1, 6)).toBe(true);\r\n      expect(isValidHivePair(2, 5)).toBe(true);\r\n      expect(isValidHivePair(3, 4)).toBe(true);\r\n    });\r\n\r\n    it('isValidHivePair returns false for invalid pairs', () => {\r\n      expect(isValidHivePair(0, 1)).toBe(false);\r\n      expect(isValidHivePair(2, 3)).toBe(false);\r\n      expect(isValidHivePair(4, 5)).toBe(false);\r\n    });\r\n\r\n    it('getHivePhase returns correct phase', () => {\r\n      expect(getHivePhase(0, 7)).toBe('H');\r\n      expect(getHivePhase(7, 0)).toBe('H'); // Order independent\r\n      expect(getHivePhase(1, 6)).toBe('I');\r\n      expect(getHivePhase(2, 5)).toBe('V');\r\n      expect(getHivePhase(3, 4)).toBe('E');\r\n    });\r\n\r\n    it('getHivePhase returns null for invalid pairs', () => {\r\n      expect(getHivePhase(0, 1)).toBeNull();\r\n      expect(getHivePhase(2, 3)).toBeNull();\r\n    });\r\n  });\r\n\r\n  // --- PREY/8 Serpentine ---\r\n  describe('PREY/8 Serpentine Pairings', () => {\r\n    it('getPreyPhase returns correct phase', () => {\r\n      expect(getPreyPhase(0, 6)).toBe('P');\r\n      expect(getPreyPhase(6, 0)).toBe('P'); // Order independent\r\n      expect(getPreyPhase(1, 7)).toBe('R');\r\n      expect(getPreyPhase(2, 4)).toBe('E');\r\n      expect(getPreyPhase(3, 5)).toBe('Y');\r\n    });\r\n\r\n    it('getPreyPhase returns null for non-PREY pairs', () => {\r\n      expect(getPreyPhase(0, 1)).toBeNull();\r\n      expect(getPreyPhase(4, 5)).toBeNull();\r\n    });\r\n  });\r\n\r\n  // --- All Ports Have Verbs ---\r\n  describe('All Ports Have Verbs', () => {\r\n    it('every port has at least one verb', () => {\r\n      for (let port = 0; port <= 7; port++) {\r\n        const verbs = getAllowedVerbs(port as Port);\r\n        expect(verbs.length).toBeGreaterThan(0);\r\n      }\r\n    });\r\n\r\n    it('no verb is shared between ports', () => {\r\n      const allVerbs = new Map<string, number>();\r\n      \r\n      for (let port = 0; port <= 7; port++) {\r\n        const verbs = getAllowedVerbs(port as Port);\r\n        for (const verb of verbs) {\r\n          if (allVerbs.has(verb)) {\r\n            // This would be a violation - verbs should be unique per port\r\n            throw new Error(`Verb \"${verb}\" is shared between ports ${allVerbs.get(verb)} and ${port}`);\r\n          }\r\n          allVerbs.set(verb, port);\r\n        }\r\n      }\r\n      \r\n      expect(allVerbs.size).toBeGreaterThan(0);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P4_RED_REGNANT/RED_REGNANT.property.test.ts":{"tests":[{"id":"294","name":"Property 8: Anti-Pattern Detection detects theater when mutation score is 100%"},{"id":"295","name":"Property 8: Anti-Pattern Detection detects theater for scores >= 99%"},{"id":"296","name":"Property 8: Anti-Pattern Detection does not flag theater for valid scores"},{"id":"297","name":"Property 8: Anti-Pattern Detection detects mutation failure for scores < 80%"},{"id":"298","name":"Property 8: Anti-Pattern Detection does not flag mutation failure for valid scores"},{"id":"299","name":"Property 10: Mutation Score Bounds accepts scores in valid range [80, 98.99]"},{"id":"300","name":"Property 10: Mutation Score Bounds rejects scores below 80%"},{"id":"301","name":"Property 10: Mutation Score Bounds rejects scores above 98.99% (Theater)"},{"id":"302","name":"Property 10: Mutation Score Bounds boundary: 80% is valid"},{"id":"303","name":"Property 10: Mutation Score Bounds boundary: 98.99% is valid"},{"id":"304","name":"Property 10: Mutation Score Bounds boundary: 79.99% is invalid"},{"id":"305","name":"Property 10: Mutation Score Bounds boundary: 99% is invalid (Theater)"},{"id":"306","name":"Property 9: Violation Schema Validation all valid violations pass schema validation"},{"id":"307","name":"Property 9: Violation Schema Validation violations with invalid type fail schema validation"},{"id":"308","name":"Blood Book Entry Schema all valid blood book entries pass schema validation"}],"source":"/**\r\n * P4 RED REGNANT - Property-Based Tests\r\n * \r\n * @port 4\r\n * @commander RED_REGNANT\r\n * @provenance: design.md\r\n * Validates: Requirements 6.6, 6.7, 6.8, 6.9, 10.1, 10.6, 10.7\r\n */\r\n\r\nimport { describe, it, expect, beforeEach } from 'vitest';\r\nimport * as fc from 'fast-check';\r\nimport { \r\n  isValidMutationScore, \r\n  isTheater, \r\n  isMutationFailure,\r\n  SILVER_STANDARD,\r\n  ViolationSchema,\r\n  BloodBookEntrySchema,\r\n} from './contracts/index.js';\r\n\r\n// --- Property 8: Anti-Pattern Detection ---\r\n// Feature: legendary-commanders-gen88, Property 8: Anti-Pattern Detection\r\n\r\ndescribe('Property 8: Anti-Pattern Detection', () => {\r\n  \r\n  it('detects theater when mutation score is 100%', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.constant(100),\r\n        (score) => {\r\n          expect(isTheater(score)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('detects theater for scores >= 99%', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 99, max: 100, noNaN: true }),\r\n        (score) => {\r\n          expect(isTheater(score)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('does not flag theater for valid scores', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 80, max: 98.99, noNaN: true }),\r\n        (score) => {\r\n          expect(isTheater(score)).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('detects mutation failure for scores < 80%', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 0, max: 79.99, noNaN: true }),\r\n        (score) => {\r\n          expect(isMutationFailure(score)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('does not flag mutation failure for valid scores', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 80, max: 100, noNaN: true }),\r\n        (score) => {\r\n          expect(isMutationFailure(score)).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Property 10: Mutation Score Bounds ---\r\n// Feature: legendary-commanders-gen88, Property 10: Mutation Score Bounds\r\n\r\ndescribe('Property 10: Mutation Score Bounds', () => {\r\n  \r\n  it('accepts scores in valid range [80, 98.99]', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 80, max: 98.99, noNaN: true }),\r\n        (score) => {\r\n          expect(isValidMutationScore(score)).toBe(true);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('rejects scores below 80%', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 0, max: 79.99, noNaN: true }),\r\n        (score) => {\r\n          expect(isValidMutationScore(score)).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('rejects scores above 98.99% (Theater)', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.double({ min: 99, max: 100, noNaN: true }),\r\n        (score) => {\r\n          expect(isValidMutationScore(score)).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('boundary: 80% is valid', () => {\r\n    expect(isValidMutationScore(80)).toBe(true);\r\n  });\r\n\r\n  it('boundary: 98.99% is valid', () => {\r\n    expect(isValidMutationScore(98.99)).toBe(true);\r\n  });\r\n\r\n  it('boundary: 79.99% is invalid', () => {\r\n    expect(isValidMutationScore(79.99)).toBe(false);\r\n  });\r\n\r\n  it('boundary: 99% is invalid (Theater)', () => {\r\n    expect(isValidMutationScore(99)).toBe(false);\r\n  });\r\n});\r\n\r\n// --- Property 9: Violation Logging Invariant ---\r\n// Feature: legendary-commanders-gen88, Property 9: Violation Logging Invariant\r\n\r\ndescribe('Property 9: Violation Schema Validation', () => {\r\n  \r\n  const violationArb = fc.record({\r\n    file: fc.string({ minLength: 1 }),\r\n    type: fc.constantFrom(\r\n      'THEATER', 'POLLUTION', 'AMNESIA', 'BESPOKE', 'VIOLATION',\r\n      'MUTATION_FAILURE', 'MUTATION_GAP', 'LATTICE_BREACH',\r\n      'BDD_MISALIGNMENT', 'OMISSION', 'PHANTOM', 'SUSPICION', 'DEBT'\r\n    ),\r\n    message: fc.string({ minLength: 1 }),\r\n  });\r\n\r\n  it('all valid violations pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(violationArb, (violation) => {\r\n        const result = ViolationSchema.safeParse(violation);\r\n        expect(result.success).toBe(true);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n\r\n  it('violations with invalid type fail schema validation', () => {\r\n    fc.assert(\r\n      fc.property(\r\n        fc.record({\r\n          file: fc.string({ minLength: 1 }),\r\n          type: fc.string().filter(s => !['THEATER', 'POLLUTION', 'AMNESIA', 'BESPOKE', 'VIOLATION',\r\n            'MUTATION_FAILURE', 'MUTATION_GAP', 'LATTICE_BREACH',\r\n            'BDD_MISALIGNMENT', 'OMISSION', 'PHANTOM', 'SUSPICION', 'DEBT'].includes(s)),\r\n          message: fc.string({ minLength: 1 }),\r\n        }),\r\n        (violation) => {\r\n          const result = ViolationSchema.safeParse(violation);\r\n          expect(result.success).toBe(false);\r\n        }\r\n      ),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n\r\n// --- Blood Book Entry Schema Validation ---\r\n\r\ndescribe('Blood Book Entry Schema', () => {\r\n  \r\n  const bloodBookEntryArb = fc.record({\r\n    id: fc.uuid(),\r\n    timestamp: fc.nat(),\r\n    violationType: fc.constantFrom(\r\n      'THEATER', 'POLLUTION', 'AMNESIA', 'BESPOKE', 'VIOLATION',\r\n      'MUTATION_FAILURE', 'MUTATION_GAP', 'LATTICE_BREACH',\r\n      'BDD_MISALIGNMENT', 'OMISSION', 'PHANTOM', 'SUSPICION', 'DEBT'\r\n    ),\r\n    artifact: fc.string({ minLength: 1 }),\r\n    details: fc.string({ minLength: 1 }),\r\n    attackVector: fc.string({ minLength: 1 }),\r\n    resolved: fc.boolean(),\r\n  });\r\n\r\n  it('all valid blood book entries pass schema validation', () => {\r\n    fc.assert(\r\n      fc.property(bloodBookEntryArb, (entry) => {\r\n        const result = BloodBookEntrySchema.safeParse(entry);\r\n        expect(result.success).toBe(true);\r\n      }),\r\n      { numRuns: 100 }\r\n    );\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P6_KRAKEN_KEEPER/KRAKEN_KEEPER.property.test.ts":{"tests":[{"id":"309","name":"P6 KRAKEN KEEPER - Property Tests Property 18: MAP-ELITE Archive Invariant stored artifact has highest fitness in cell"},{"id":"310","name":"P6 KRAKEN KEEPER - Property Tests Property 18: MAP-ELITE Archive Invariant empty cell accepts any entry"},{"id":"311","name":"P6 KRAKEN KEEPER - Property Tests Property 18: MAP-ELITE Archive Invariant out-of-bounds cell is rejected"},{"id":"312","name":"P6 KRAKEN KEEPER - Property Tests Property 18: MAP-ELITE Archive Invariant archive tracks total entries correctly"},{"id":"313","name":"P6 KRAKEN KEEPER - Property Tests Archive Schema Validation archive entry validates against schema"},{"id":"314","name":"P6 KRAKEN KEEPER - Property Tests Archive Schema Validation archive validates against schema"},{"id":"315","name":"P6 KRAKEN KEEPER - Property Tests Archive Schema Validation assimilation result validates against schema"},{"id":"316","name":"P6 KRAKEN KEEPER - Property Tests Archive Query queries by cell range"},{"id":"317","name":"P6 KRAKEN KEEPER - Property Tests Archive Query queries by minimum fitness"},{"id":"318","name":"P6 KRAKEN KEEPER - Property Tests Archive Query respects query limit"},{"id":"319","name":"P6 KRAKEN KEEPER - Property Tests Archive Query getElite returns undefined for empty cell"},{"id":"320","name":"P6 KRAKEN KEEPER - Property Tests Archive Query getElite returns undefined for out-of-bounds"}],"source":"/**\r\n * P6 KRAKEN KEEPER - Property Tests\r\n * \r\n * @port 6\r\n * @commander KRAKEN_KEEPER\r\n * @verb ASSIMILATE / STORE\r\n * @provenance: LEGENDARY_COMMANDERS_V9.md\r\n * Validates: Property 18 (MAP-ELITE Archive Invariant)\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport {\r\n  ArchiveEntrySchema,\r\n  MapEliteArchiveSchema,\r\n  AssimilationResultSchema,\r\n  createArchive,\r\n  assimilate,\r\n  getElite,\r\n  queryArchive,\r\n  type ArchiveEntry,\r\n  type MapEliteArchive,\r\n} from './contracts/index.js';\r\n\r\n\r\n// Helper to create test entries\r\nfunction createTestEntry(x: number, y: number, fitness: number): ArchiveEntry {\r\n  return {\r\n    id: crypto.randomUUID(),\r\n    timestamp: Date.now(),\r\n    artifact: `artifact-${x}-${y}`,\r\n    fitness,\r\n    cell: { x, y },\r\n    metadata: {\r\n      generation: 1,\r\n      sourcePort: 6,\r\n      tags: [],\r\n    },\r\n    hash: `sha256:${'a'.repeat(64)}`,\r\n  };\r\n}\r\n\r\ndescribe('P6 KRAKEN KEEPER - Property Tests', () => {\r\n  // --- Property 18: MAP-ELITE Archive Invariant ---\r\n  describe('Property 18: MAP-ELITE Archive Invariant', () => {\r\n    it('stored artifact has highest fitness in cell', () => {\r\n      const archive = createArchive('test', 10, 10);\r\n      \r\n      // Insert entry with fitness 0.5\r\n      const entry1 = createTestEntry(3, 3, 0.5);\r\n      assimilate(archive, entry1);\r\n      \r\n      // Insert entry with fitness 0.3 (lower) - should NOT replace\r\n      const entry2 = createTestEntry(3, 3, 0.3);\r\n      const result2 = assimilate(archive, entry2);\r\n      expect(result2.success).toBe(false);\r\n      expect(result2.reason).toBe('LOWER_FITNESS');\r\n      \r\n      // Insert entry with fitness 0.8 (higher) - should replace\r\n      const entry3 = createTestEntry(3, 3, 0.8);\r\n      const result3 = assimilate(archive, entry3);\r\n      expect(result3.success).toBe(true);\r\n      expect(result3.displaced?.fitness).toBe(0.5);\r\n      \r\n      // Verify elite is the highest fitness\r\n      const elite = getElite(archive, 3, 3);\r\n      expect(elite?.fitness).toBe(0.8);\r\n    });\r\n\r\n    it('empty cell accepts any entry', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      const entry = createTestEntry(2, 2, 0.1);\r\n      \r\n      const result = assimilate(archive, entry);\r\n      expect(result.success).toBe(true);\r\n      expect(result.reason).toBe('NEW_ELITE');\r\n    });\r\n\r\n\r\n    it('out-of-bounds cell is rejected', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      const entry = createTestEntry(10, 10, 0.9); // Out of bounds\r\n      \r\n      const result = assimilate(archive, entry);\r\n      expect(result.success).toBe(false);\r\n      expect(result.reason).toBe('INVALID_ENTRY');\r\n    });\r\n\r\n    it('archive tracks total entries correctly', () => {\r\n      const archive = createArchive('test', 3, 3);\r\n      expect(archive.totalEntries).toBe(0);\r\n      \r\n      assimilate(archive, createTestEntry(0, 0, 0.5));\r\n      expect(archive.totalEntries).toBe(1);\r\n      \r\n      assimilate(archive, createTestEntry(1, 1, 0.5));\r\n      expect(archive.totalEntries).toBe(2);\r\n      \r\n      // Replacing doesn't increase count\r\n      assimilate(archive, createTestEntry(0, 0, 0.9));\r\n      expect(archive.totalEntries).toBe(2);\r\n    });\r\n  });\r\n\r\n  // --- Archive Schema Validation ---\r\n  describe('Archive Schema Validation', () => {\r\n    it('archive entry validates against schema', () => {\r\n      const entry = createTestEntry(1, 2, 0.75);\r\n      const result = ArchiveEntrySchema.safeParse(entry);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('archive validates against schema', () => {\r\n      const archive = createArchive('test-archive', 4, 4);\r\n      const result = MapEliteArchiveSchema.safeParse(archive);\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('assimilation result validates against schema', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      const entry = createTestEntry(2, 2, 0.6);\r\n      const result = assimilate(archive, entry);\r\n      \r\n      const parsed = AssimilationResultSchema.safeParse(result);\r\n      expect(parsed.success).toBe(true);\r\n    });\r\n  });\r\n\r\n\r\n  // --- Query Tests ---\r\n  describe('Archive Query', () => {\r\n    it('queries by cell range', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      assimilate(archive, createTestEntry(0, 0, 0.5));\r\n      assimilate(archive, createTestEntry(1, 1, 0.6));\r\n      assimilate(archive, createTestEntry(4, 4, 0.7));\r\n      \r\n      const results = queryArchive(archive, { cellRange: { minX: 0, maxX: 2, minY: 0, maxY: 2 }, limit: 100 });\r\n      expect(results).toHaveLength(2);\r\n    });\r\n\r\n    it('queries by minimum fitness', () => {\r\n      const archive = createArchive('test', 3, 3);\r\n      assimilate(archive, createTestEntry(0, 0, 0.3));\r\n      assimilate(archive, createTestEntry(1, 1, 0.6));\r\n      assimilate(archive, createTestEntry(2, 2, 0.9));\r\n      \r\n      const results = queryArchive(archive, { minFitness: 0.5, limit: 100 });\r\n      expect(results).toHaveLength(2);\r\n      expect(results.every(e => e.fitness >= 0.5)).toBe(true);\r\n    });\r\n\r\n    it('respects query limit', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      for (let i = 0; i < 5; i++) {\r\n        assimilate(archive, createTestEntry(i, 0, 0.5 + i * 0.1));\r\n      }\r\n      \r\n      const results = queryArchive(archive, { limit: 3 });\r\n      expect(results).toHaveLength(3);\r\n    });\r\n\r\n    it('getElite returns undefined for empty cell', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      expect(getElite(archive, 2, 2)).toBeUndefined();\r\n    });\r\n\r\n    it('getElite returns undefined for out-of-bounds', () => {\r\n      const archive = createArchive('test', 5, 5);\r\n      expect(getElite(archive, 10, 10)).toBeUndefined();\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P1_WEB_WEAVER/WEB_WEAVER.test.ts":{"tests":[{"id":"321","name":"P1 Web Weaver bridge() validates valid messages against schema"},{"id":"322","name":"P1 Web Weaver bridge() rejects invalid messages with errors"},{"id":"323","name":"P1 Web Weaver fuse() merges two schemas"},{"id":"324","name":"P1 Web Weaver fuse() fused schema requires all fields"},{"id":"325","name":"P1 Web Weaver wrapEnvelope() creates valid VacuoleEnvelope"},{"id":"326","name":"P1 Web Weaver wrapEnvelope() envelope passes schema validation"},{"id":"327","name":"P1 Web Weaver WebWeaver class validateEnvelope accepts valid envelopes"},{"id":"328","name":"P1 Web Weaver WebWeaver class validateEnvelope rejects invalid envelopes"},{"id":"329","name":"P1 Web Weaver WebWeaver class validateReceipt accepts valid receipts"},{"id":"330","name":"P1 Web Weaver WebWeaver class validateReceipt rejects scores below 80%"},{"id":"331","name":"P1 Web Weaver WebWeaver class validateReceipt rejects scores above 98.99%"}],"source":"/**\r\n * P1 WEB WEAVER - Unit Tests\r\n * \r\n * @port 1\r\n * @commander WEB_WEAVER\r\n * @provenance: design.md\r\n * Validates: Requirements 3.4, 3.5, 3.6\r\n */\r\n\r\nimport { describe, it, expect } from 'vitest';\r\nimport { z } from 'zod';\r\nimport {\r\n  WebWeaver,\r\n  bridge,\r\n  fuse,\r\n  wrapEnvelope,\r\n  VacuoleEnvelopeSchema,\r\n  SilverPromotionReceiptSchema,\r\n} from './WEB_WEAVER.js';\r\n\r\ndescribe('P1 Web Weaver', () => {\r\n  const weaver = new WebWeaver();\r\n\r\n  describe('bridge()', () => {\r\n    it('validates valid messages against schema', () => {\r\n      const schema = z.object({ name: z.string(), age: z.number() });\r\n      const result = bridge({ name: 'test', age: 25 }, schema);\r\n      \r\n      expect(result.success).toBe(true);\r\n      if (result.success) {\r\n        expect(result.data.name).toBe('test');\r\n        expect(result.data.age).toBe(25);\r\n      }\r\n    });\r\n\r\n    it('rejects invalid messages with errors', () => {\r\n      const schema = z.object({ name: z.string(), age: z.number() });\r\n      const result = bridge({ name: 123, age: 'invalid' }, schema);\r\n      \r\n      expect(result.success).toBe(false);\r\n      if (!result.success) {\r\n        expect(result.errors.length).toBeGreaterThan(0);\r\n      }\r\n    });\r\n  });\r\n\r\n  describe('fuse()', () => {\r\n    it('merges two schemas', () => {\r\n      const schemaA = z.object({ name: z.string() });\r\n      const schemaB = z.object({ age: z.number() });\r\n      const fused = fuse(schemaA, schemaB);\r\n      \r\n      const result = fused.safeParse({ name: 'test', age: 25 });\r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('fused schema requires all fields', () => {\r\n      const schemaA = z.object({ name: z.string() });\r\n      const schemaB = z.object({ age: z.number() });\r\n      const fused = fuse(schemaA, schemaB);\r\n      \r\n      const result = fused.safeParse({ name: 'test' });\r\n      expect(result.success).toBe(false);\r\n    });\r\n  });\r\n\r\n  describe('wrapEnvelope()', () => {\r\n    it('creates valid VacuoleEnvelope', () => {\r\n      const envelope = wrapEnvelope(1, 7, 'BRIDGE', { data: 'test' });\r\n      \r\n      expect(envelope.sourcePort).toBe(1);\r\n      expect(envelope.targetPort).toBe(7);\r\n      expect(envelope.verb).toBe('BRIDGE');\r\n      expect(envelope.payload).toEqual({ data: 'test' });\r\n      expect(envelope.metadata.priority).toBe('normal');\r\n    });\r\n\r\n    it('envelope passes schema validation', () => {\r\n      const envelope = wrapEnvelope(0, 7, 'OBSERVE', { query: 'test' }, 'high');\r\n      const result = VacuoleEnvelopeSchema.safeParse(envelope);\r\n      \r\n      expect(result.success).toBe(true);\r\n    });\r\n  });\r\n\r\n  describe('WebWeaver class', () => {\r\n    it('validateEnvelope accepts valid envelopes', () => {\r\n      const envelope = weaver.wrapEnvelope(1, 6, 'BRIDGE', {});\r\n      const result = weaver.validateEnvelope(envelope);\r\n      \r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('validateEnvelope rejects invalid envelopes', () => {\r\n      const result = weaver.validateEnvelope({ invalid: true });\r\n      \r\n      expect(result.success).toBe(false);\r\n    });\r\n\r\n    it('validateReceipt accepts valid receipts', () => {\r\n      const receipt = {\r\n        artifact: 'P4_RED_REGNANT/RED_REGNANT.ts',\r\n        mutationScore: 88.5,\r\n        timestamp: '2026-01-07T19:00:00Z',\r\n        hash: 'sha256:' + 'a'.repeat(64),\r\n        strykerConfig: 'stryker.p4.config.mjs',\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      };\r\n      const result = weaver.validateReceipt(receipt);\r\n      \r\n      expect(result.success).toBe(true);\r\n    });\r\n\r\n    it('validateReceipt rejects scores below 80%', () => {\r\n      const receipt = {\r\n        artifact: 'test.ts',\r\n        mutationScore: 79.99,\r\n        timestamp: '2026-01-07T19:00:00Z',\r\n        hash: 'sha256:' + 'a'.repeat(64),\r\n        strykerConfig: 'stryker.config.mjs',\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      };\r\n      const result = weaver.validateReceipt(receipt);\r\n      \r\n      expect(result.success).toBe(false);\r\n    });\r\n\r\n    it('validateReceipt rejects scores above 98.99%', () => {\r\n      const receipt = {\r\n        artifact: 'test.ts',\r\n        mutationScore: 99,\r\n        timestamp: '2026-01-07T19:00:00Z',\r\n        hash: 'sha256:' + 'a'.repeat(64),\r\n        strykerConfig: 'stryker.config.mjs',\r\n        propertyTestsPassed: true,\r\n        zodContractsPresent: true,\r\n        provenanceHeadersPresent: true,\r\n      };\r\n      const result = weaver.validateReceipt(receipt);\r\n      \r\n      expect(result.success).toBe(false);\r\n    });\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P4_RED_REGNANT/hive_agent_rules.test.ts":{"tests":[{"id":"332","name":"HFO HIVE AGENT Enforcement should have a recent SEARCH_GROUNDING event on the blackboard"},{"id":"333","name":"HFO HIVE AGENT Enforcement should have a recent THINKING_GROUNDING event on the blackboard"},{"id":"334","name":"HFO HIVE AGENT Enforcement should have a recent MEMORY_GROUNDING event on the blackboard"}],"source":"import { describe, it, expect } from 'vitest';\r\nimport * as fs from 'node:fs';\r\nimport * as path from 'node:path';\r\n\r\nconst BLACKBOARD_PATH = path.resolve(process.cwd(), 'obsidianblackboard.jsonl');\r\n\r\ndescribe('HFO HIVE AGENT Enforcement', () => {\r\n    it('should have a recent SEARCH_GROUNDING event on the blackboard', () => {\r\n        const content = fs.readFileSync(BLACKBOARD_PATH, 'utf-8');\r\n        const lines = content.trim().split('\\n');\r\n        const searchGrounding = lines.some(line => {\r\n            if (!line) return false;\r\n            try {\r\n                const entry = JSON.parse(line);\r\n                const type = entry.type || entry.event;\r\n                const ts = entry.ts || entry.timestamp || entry.time;\r\n                return type === 'SEARCH_GROUNDING' && (new Date().getTime() - new Date(ts).getTime() < 86400000); // 24 hours\r\n            } catch (err) {\r\n                return false;\r\n            }\r\n        });\r\n        expect(searchGrounding).toBe(true);\r\n    });\r\n\r\n    it('should have a recent THINKING_GROUNDING event on the blackboard', () => {\r\n        const content = fs.readFileSync(BLACKBOARD_PATH, 'utf-8');\r\n        const lines = content.trim().split('\\n');\r\n        const thinkingGrounding = lines.some(line => {\r\n            if (!line) return false;\r\n            try {\r\n                const entry = JSON.parse(line);\r\n                const type = entry.type || entry.event;\r\n                const ts = entry.ts || entry.timestamp || entry.time;\r\n                return type === 'THINKING_GROUNDING' && (new Date().getTime() - new Date(ts).getTime() < 86400000); // 24 hours\r\n            } catch (err) {\r\n                return false;\r\n            }\r\n        });\r\n        expect(thinkingGrounding).toBe(true);\r\n    });\r\n\r\n    it('should have a recent MEMORY_GROUNDING event on the blackboard', () => {\r\n        const content = fs.readFileSync(BLACKBOARD_PATH, 'utf-8');\r\n        const lines = content.trim().split('\\n');\r\n        const memoryGrounding = lines.some(line => {\r\n            if (!line) return false;\r\n            try {\r\n                const entry = JSON.parse(line);\r\n                const type = entry.type || entry.event;\r\n                const ts = entry.ts || entry.timestamp || entry.time;\r\n                return type === 'MEMORY_GROUNDING' && (new Date().getTime() - new Date(ts).getTime() < 86400000); // 24 hours\r\n            } catch (err) {\r\n                return false;\r\n            }\r\n        });\r\n        expect(memoryGrounding).toBe(true);\r\n    });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P4_RED_REGNANT/debug.test.ts":{"tests":[{"id":"335","name":"debug audit"}],"source":"\r\nimport { it, expect } from 'vitest';\r\nimport { auditContent, violations, clearViolations } from './RED_REGNANT.js';\r\n\r\nit('debug audit', () => {\r\n    clearViolations();\r\n    auditContent('test.ts', '// TODO: something');\r\n    console.log('VIOLATIONS:', JSON.stringify(violations, null, 2));\r\n    expect(violations[0].type).toBe('AMNESIA');\r\n});\r\n"},"hot_obsidian_sandbox/bronze/baseline.test.ts":{"tests":[{"id":"336","name":"Gen 88 Baseline should verify that the cleanroom is active"}],"source":"import { describe, it, expect } from 'vitest';\r\n\r\ndescribe('Gen 88 Baseline', () => {\r\n  it('should verify that the cleanroom is active', () => {\r\n    expect(true).toBe(true);\r\n  });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/infra/tavily_search.test.ts":{"tests":[{"id":"337","name":"Sentinel Grounding exists as a concept"}],"source":"import { describe, it, expect } from 'vitest';\r\n\r\ndescribe('Sentinel Grounding', () => {\r\n    it('exists as a concept', () => {\r\n        expect(true).to.not.be.false;\r\n    });\r\n});\r\n"},"hot_obsidian_sandbox/bronze/P4_RED_REGNANT/silver_sim/logic.test.ts":{"tests":[{"id":"338","name":"x"}],"source":"import { test } from 'vitest'; test('x', () => {});"}},"projectRoot":"C:\\Dev\\active\\hfo_gen88","config":{"packageManager":"npm","reporters":["clear-text","progress","json"],"testRunner":"vitest","coverageAnalysis":"perTest","mutate":["hot_obsidian_sandbox/bronze/P0_LIDLESS_LEGION/contracts/index.ts"],"ignorePatterns":["cold_obsidian_sandbox/**","hot_obsidian_sandbox/bronze/archive*/**","hot_obsidian_sandbox/bronze/quarantine/**",".git/**",".venv/**","node_modules/**",".stryker-tmp*/**"],"vitest":{"configFile":"vitest.mutation.config.ts"},"tempDirName":".stryker-tmp-p0","cleanTempDir":"always","timeoutMS":5000,"timeoutFactor":1.5,"concurrency":2,"maxTestRunnerReuse":10,"disableBail":true,"jsonReporter":{"fileName":"hot_obsidian_sandbox/bronze/P0_LIDLESS_LEGION/mutation-report.json"},"configFile":"hot_obsidian_sandbox/bronze/infra/stryker/stryker.p0.config.mjs","allowConsoleColors":true,"checkers":[],"checkerNodeArgs":[],"commandRunner":{"command":"npm test"},"clearTextReporter":{"allowColor":true,"allowEmojis":false,"logTests":true,"maxTestsToLog":3,"reportTests":true,"reportMutants":true,"reportScoreTable":true,"skipFull":false},"dashboard":{"baseUrl":"https://dashboard.stryker-mutator.io/api/reports","reportType":"full"},"dryRunOnly":false,"eventReporter":{"baseDir":"reports/mutation/events"},"ignoreStatic":false,"incremental":false,"incrementalFile":"reports/stryker-incremental.json","force":false,"fileLogLevel":"off","inPlace":false,"logLevel":"info","maxConcurrentTestRunners":9007199254740991,"mutator":{"plugins":null,"excludedMutations":[]},"plugins":["@stryker-mutator/*"],"appendPlugins":[],"htmlReporter":{"fileName":"reports/mutation/mutation.html"},"disableTypeChecks":true,"symlinkNodeModules":true,"testRunnerNodeArgs":[],"thresholds":{"high":80,"low":60,"break":null},"dryRunTimeoutMinutes":5,"tsconfigFile":"tsconfig.json","warnings":true,"allowEmpty":false,"ignorers":[],"typescriptChecker":{"prioritizePerformanceOverAccuracy":true}},"framework":{"name":"StrykerJS","version":"8.7.1","branding":{"homepageUrl":"https://stryker-mutator.io","imageUrl":"data:image/svg+xml;utf8,%3Csvg viewBox='0 0 1458 1458' xmlns='http://www.w3.org/2000/svg' fill-rule='evenodd' clip-rule='evenodd' stroke-linejoin='round' stroke-miterlimit='2'%3E%3Cpath fill='none' d='M0 0h1458v1458H0z'/%3E%3CclipPath id='a'%3E%3Cpath d='M0 0h1458v1458H0z'/%3E%3C/clipPath%3E%3Cg clip-path='url(%23a)'%3E%3Cpath d='M1458 729c0 402.655-326.345 729-729 729S0 1131.655 0 729C0 326.445 326.345 0 729 0s729 326.345 729 729' fill='%23e74c3c' fill-rule='nonzero'/%3E%3Cpath d='M778.349 1456.15L576.6 1254.401l233-105 85-78.668v-64.332l-257-257-44-187-50-208 251.806-82.793L1076.6 389.401l380.14 379.15c-19.681 367.728-311.914 663.049-678.391 687.599z' fill-opacity='.3'/%3E%3Cpath d='M753.4 329.503c41.79 0 74.579 7.83 97.925 25.444 23.571 18.015 41.69 43.956 55.167 77.097l11.662 28.679 165.733-58.183-14.137-32.13c-26.688-60.655-64.896-108.61-114.191-144.011-49.329-35.423-117.458-54.302-204.859-54.302-50.78 0-95.646 7.376-134.767 21.542-40.093 14.671-74.09 34.79-102.239 60.259-28.84 26.207-50.646 57.06-65.496 92.701-14.718 35.052-22.101 72.538-22.101 112.401 0 72.536 20.667 133.294 61.165 182.704 38.624 47.255 98.346 88.037 179.861 121.291 42.257 17.475 78.715 33.125 109.227 46.994 27.193 12.361 49.294 26.124 66.157 41.751 15.309 14.186 26.497 30.584 33.63 49.258 7.721 20.214 11.16 45.69 11.16 76.402 0 28.021-4.251 51.787-13.591 71.219-8.832 18.374-20.171 33.178-34.523 44.219-14.787 11.374-31.193 19.591-49.393 24.466-19.68 5.359-39.14 7.993-58.69 7.993-29.359 0-54.387-3.407-75.182-10.747-20.112-7.013-37.144-16.144-51.259-27.486-13.618-11.009-24.971-23.766-33.744-38.279-9.64-15.8-17.272-31.924-23.032-48.408l-10.965-31.376-161.669 60.585 10.734 30.124c10.191 28.601 24.197 56.228 42.059 82.748 18.208 27.144 41.322 51.369 69.525 72.745 27.695 21.075 60.904 38.218 99.481 51.041 37.777 12.664 82.004 19.159 132.552 19.159 49.998 0 95.818-8.321 137.611-24.622 42.228-16.471 78.436-38.992 108.835-67.291 30.719-28.597 54.631-62.103 71.834-100.642 17.263-38.56 25.923-79.392 25.923-122.248 0-54.339-8.368-100.37-24.208-138.32-16.29-38.759-38.252-71.661-65.948-98.797-26.965-26.418-58.269-48.835-93.858-67.175-33.655-17.241-69.196-33.11-106.593-47.533-35.934-13.429-65.822-26.601-89.948-39.525-22.153-11.868-40.009-24.21-53.547-37.309-11.429-11.13-19.83-23.678-24.718-37.664-5.413-15.49-7.98-33.423-7.98-53.577 0-40.883 11.293-71.522 37.086-90.539 28.443-20.825 64.985-30.658 109.311-30.658z' fill='%23f1c40f' fill-rule='nonzero'/%3E%3Cpath d='M720 0h18v113h-18zM1458 738v-18h-113v18h113zM720 1345h18v113h-18zM113 738v-18H0v18h113z'/%3E%3C/g%3E%3C/svg%3E"},"dependencies":{"@stryker-mutator/typescript-checker":"8.7.1","typescript":"5.9.3","webpack":"5.104.1"}}}